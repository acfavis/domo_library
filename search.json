[
  {
    "objectID": "client/domoauth.html",
    "href": "client/domoauth.html",
    "title": "DomoAuth",
    "section": "",
    "text": "Stand alone functions for users who prefer a functional programming approach\n\n\n\nsource\n\n\n\n get_full_auth (domo_instance:str, domo_username:str, domo_password:str,\n                session:Optional[httpx.AsyncClient]=None,\n                debug_api:bool=False)\n\nuses username and password authentication to retrieve a full_auth access token\n\n\n\nimport os\n\nres = await get_full_auth(\n    domo_instance=\"domo-dojo\",\n    domo_username=\"test@test.com\",\n    domo_password=\"fake password\",\n)\nres\n\nResponseGetData(status=200, response={'success': False, 'reason': 'INVALID_CREDENTIALS'}, is_success=True)\n\n\n\nres = await get_full_auth(domo_instance=\"test\",\n                          domo_username=\"fake@test.com\", \n                          domo_password=\"fake password\")\n\n\nassert res.status == 403\n\n\nres = await get_full_auth(domo_instance=\"domo-dojo\",\n                          domo_username=\"jae@onyxreporting.com\",\n                          domo_password=os.environ['DOJO_PASSWORD'])\nassert res.status == 200\n\nThe 403 response is expected because test.domo.com presumeably does not exist or access if forbidden.\n\n\n\n\n\n\nsource\n\n\n\n get_developer_auth (domo_client_id:str, domo_client_secret:str,\n                     session:Optional[httpx.AsyncClient]=None,\n                     debug_api:bool=False)\n\nonly use for authenticating against apis documented under developer.domo.com\n\n\nThe 401 response is expected because we are using invalid credentials\n\nawait get_developer_auth(domo_client_id=\"test_id\",\n                         domo_client_secret=\"test_secret\"\n                         )\n\nResponseGetData(status=401, response='Unauthorized', is_success=False)\n\n\n\n\n\n\n\nThis access_token based authentication assumes the user has been provided a valid access token from Domo > Admin > Authentication > Access Token so authentication routes are actually not required.\nPer the Domo JavaCLI implementation, users can test the validity of the access_token agains the ‘me’ API\n!! Note about the Me API !! It appears that access_token authentication will direct the\n\nsource\n\n\n\n test_access_token (domo_access_token:str, domo_instance:str,\n                    session:Optional[httpx.AsyncClient]=None,\n                    debug_api:bool=False)\n\nwill attempt to validate against the ‘me’ API. This is the same authentication test the Domo Java CLI uses.\n\n\n\nimport os\n\nawait test_access_token(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN']\n)\n\nResponseGetData(status=200, response={'id': 1893952720, 'invitorUserId': 587894148, 'displayName': 'Jae Wilson1', 'department': 'Business Improvement', 'userName': 'jae@onyxreporting.com', 'emailAddress': 'jae@onyxreporting.com', 'avatarKey': 'c605f478-0cd2-4451-9fd4-d82090b71e66', 'accepted': True, 'userType': 'USER', 'modified': 1679004195646, 'created': 1588960518, 'role': 'Admin', 'rights': 63, 'active': True, 'pending': False, 'systemUser': False, 'anonymous': False}, is_success=True)"
  },
  {
    "objectID": "client/domoauth.html#domoauth-error-classes",
    "href": "client/domoauth.html#domoauth-error-classes",
    "title": "DomoAuth",
    "section": "DomoAuth Error Classes",
    "text": "DomoAuth Error Classes\n\nsource\n\nNoAccessTokenReturned\n\n NoAccessTokenReturned (function_name:Optional[str]=None,\n                        status:Optional[int]=None, message:str='No\n                        AccessToken returned',\n                        domo_instance:Optional[str]=None)\n\nbase exception\n\nsource\n\n\nInvalidInstanceError\n\n InvalidInstanceError (function_name:Optional[str]=None,\n                       status:Optional[int]=None, message='invalid\n                       instance', domo_instance:Optional[str]=None)\n\nreturn if invalid domo_instance sent to API\n\nsource\n\n\nInvalidAuthTypeError\n\n InvalidAuthTypeError (required_auth_type:__main__.DomoAuth,\n                       function_name:Optional[str]=None,\n                       domo_instance:Optional[str]=None)\n\nreturn invalid Auth type sent to API\n\nsource\n\n\nInvalidCredentialsError\n\n InvalidCredentialsError (function_name:Optional[str]=None,\n                          status:Optional[int]=None, message='invalid\n                          credentials', domo_instance:Optional[str]=None)\n\nreturn invalid credentials sent to API\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfunction_name\ntyping.Optional[str]\nNone\n\n\n\nstatus\ntyping.Optional[int]\nNone\nAPI request status\n\n\nmessage\nstr\ninvalid credentials\n\n\n\ndomo_instance\ntyping.Optional[str]\nNone"
  },
  {
    "objectID": "client/domoauth.html#domofullauth",
    "href": "client/domoauth.html#domofullauth",
    "title": "DomoAuth",
    "section": "DomoFullAuth",
    "text": "DomoFullAuth\n\nsource\n\nDomoFullAuth\n\n DomoFullAuth (domo_instance:str, domo_username:str, domo_password:str,\n               token:Optional[str]=None, token_name:Optional[str]=None,\n               user_id:Optional[str]=None, auth_header:dict=<factory>,\n               url_manual_login:Optional[str]=None)\n\nuse for full authentication token\n\nsample implementations of DomoFullAuth\n\ntry:\n    full_auth = DomoFullAuth(domo_instance=\"domo-dojo\",\n                             domo_username=\"test12@domo.com\",\n                             domo_password=\"test1234\")\n    res = await full_auth.get_auth_token()\n\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 200 - INVALID_CREDENTIALS at domo-dojo\n\n\n\ntry:\n    full_auth = DomoFullAuth(domo_instance=\"test\",\n                             domo_username=\"test12@domo.com\",\n                             domo_password=\"test1234\")\n    \n    await full_auth.get_auth_token()\n\n\nexcept InvalidInstanceError as e:\n    print(e)\n\nStatus 403 - INVALID INSTANCE at test\n\n\n\nimport os\ntry:\n    full_auth = DomoFullAuth(domo_instance=\"domo-dojo\",\n                             domo_username=\"jae@onyxreporting.com\",\n                             domo_password=os.environ['DOJO_PASSWORD'])\n\n    await full_auth.get_auth_token()\n\n\nexcept InvalidInstanceError as e:\n    print(e)\n\nassert(full_auth.token)\nfull_auth\n\nDomoFullAuth(domo_instance='domo-dojo', domo_username='jae@onyxreporting.com', token_name='full_auth', url_manual_login='https://domo-dojo.domo.com/auth/index?domoManualLogin=true')"
  },
  {
    "objectID": "client/domoauth.html#domotokenauth",
    "href": "client/domoauth.html#domotokenauth",
    "title": "DomoAuth",
    "section": "DomoTokenAuth",
    "text": "DomoTokenAuth\n\nsource\n\nDomoTokenAuth\n\n DomoTokenAuth (domo_instance:str, domo_access_token:str,\n                token:Optional[str]=None, token_name:Optional[str]=None,\n                user_id:Optional[str]=None, auth_header:dict=<factory>,\n                url_manual_login:Optional[str]=None)\n\nuse for access_token authentication. Tokens are generated in domo > admin > access token Necessary in cases where direct sign on is not permitted\n\nSample implementation of DomoTokenAuth\n\ntry:\n    domo_auth = DomoTokenAuth(domo_instance=\"domo-dojo\",\n                              domo_access_token='fake password')\n    token = await domo_auth.get_auth_token()\n\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 401 - Unauthorized at domo-dojo"
  },
  {
    "objectID": "client/domoauth.html#domodeveloperauth",
    "href": "client/domoauth.html#domodeveloperauth",
    "title": "DomoAuth",
    "section": "DomoDeveloperAuth",
    "text": "DomoDeveloperAuth\n\nsource\n\nDomoDeveloperAuth\n\n DomoDeveloperAuth (domo_client_id:str, domo_client_secret:str)\n\nuse for full authentication token\n\nSample implementations of DomoDeveloperAuth\n\ndomo_client_id = \"test_client\"\ndomo_client_secret = \"test_secret\"\n\ntry:\n    domo_auth = DomoDeveloperAuth(domo_client_id, domo_client_secret)\n    await domo_auth.get_auth_token()\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 401 - Unauthorized"
  },
  {
    "objectID": "client/domoerror.html",
    "href": "client/domoerror.html",
    "title": "DomoError",
    "section": "",
    "text": "source\n\nDomoError\n\n DomoError (entity_id:Optional[str]=None,\n            function_name:Optional[str]=None, status:Optional[int]=None,\n            message:str='error', domo_instance:Optional[str]=None)\n\nbase exception\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nentity_id\ntyping.Optional[str]\nNone\n\n\n\nfunction_name\ntyping.Optional[str]\nNone\n\n\n\nstatus\ntyping.Optional[int]\nNone\nAPI request status\n\n\nmessage\nstr\nerror\n.domo.com\n\n\ndomo_instance\ntyping.Optional[str]\nNone\n\n\n\n\n\ntry:\n    raise DomoError(entity_id=\"ds_123\",\n                    function_name=\"create_dataset\",\n                    status=403,\n                    message=\"invalide path\")\nexcept DomoError as e:\n    print(e)\n\ncreate_dataset: ds_123 :Status 403 - invalide path\n\n\n\n\nStandard PreRequisite Errors\n\nsource\n\nAuthNotProvidedError\n\n AuthNotProvidedError (entity_id, function_name, message='valid Auth\n                       object not provided', status=None,\n                       domo_instance=None)\n\nbase exception\n\nsource\n\n\nDatasetNotProvidedError\n\n DatasetNotProvidedError (function_name, message='dataset_id not\n                          provided', domo_instance=None, entity_id=None,\n                          status=None)\n\nbase exception"
  },
  {
    "objectID": "client/logger.html",
    "href": "client/logger.html",
    "title": "Logger",
    "section": "",
    "text": "source"
  },
  {
    "objectID": "client/logger.html#logger-traceback-methods",
    "href": "client/logger.html#logger-traceback-methods",
    "title": "Logger",
    "section": "Logger traceback methods",
    "text": "Logger traceback methods\nPrivate methods for adding traceback details to logs\n\nsource\n\nLogger._get_traceback\n\n Logger._get_traceback (root_module:str='<module>', num_stacks_to_drop=0)\n\nmethod that retrieves traceback\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nroot_module\nstr\n\n\n\n\nnum_stacks_to_drop\nint\n0\ndrop entries from the top of stack to exclude the functions that retrieve the traceback\n\n\nReturns\n[<class ‘traceback.FrameSummary’>]\n\n\n\n\n\n\nsource\n\n\nTracebackDetails\n\n TracebackDetails (function_name:str, file_name:str, function_trail:str)\n\nresult of _get_traceback_details function\n\nsource\n\n\nLogger._get_traceback_details\n\n Logger._get_traceback_details\n                                (traceback_list:[<class'traceback.FrameSum\n                                mary'>])\n\nreturns TracebackDetails, for the entry at the top of the stack\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntraceback_list\n[<class ‘traceback.FrameSummary’>]\n\n\n\nReturns\nTracebackDetails\ndescriptive summary from the top of the traceback\n\n\n\n\n\nsample implementations of stack tracing methods\n\nimport pandas as pd\n\n\ndef custom_write_logs_fn(logs):\n    print(\"printing logs\")\n    return pd.DataFrame(logs)\n\n\nlogger = Logger(app_name=\"test\", output_fn=custom_write_logs_fn)\n\n\ndef test_trace():\n    return logger._get_traceback(num_stacks_to_drop=1)\n\n\n# print traceback for the test_trace function\n# notice with num_stacks_to_drop = 1 we exclude the _get_traceback function from the traceback\ntb = test_trace()\nprint({\"traceback function\": [line[2] for line in tb]})\n\n\ndef test_get_details():\n    tb = logger._get_traceback(num_stacks_to_drop=1)\n    return logger._get_traceback_details(tb)\n\n\n# print traceback details for test_get_details function\ntest_get_details().__dict__\n\n{'traceback function': ['<module>', 'test_trace']}\n\n\n{'function_name': 'test_get_details',\n 'file_name': '<ipython-input-1-67d667b8d98b>',\n 'function_trail': '<module> -> test_get_details'}\n\n\n\n# assert that the result of test_trace is of type FrameSummary\ntest_eq(type(tb[0]), traceback.FrameSummary)"
  },
  {
    "objectID": "client/logger.html#logger-logging-methods",
    "href": "client/logger.html#logger-logging-methods",
    "title": "Logger",
    "section": "Logger logging methods",
    "text": "Logger logging methods\n\nsource\n\nLogger.log_warning\n\n Logger.log_warning (message, entity_id:Optional[str]=None,\n                     domo_instance:Optional[str]=None, debug_log=False,\n                     num_stacks_to_drop=3)\n\nlog a warning message\n\nsource\n\n\nLogger.log_error\n\n Logger.log_error (message, entity_id:Optional[str]=None,\n                   domo_instance:Optional[str]=None, debug_log=False,\n                   num_stacks_to_drop=3)\n\nlog an error message\n\nsource\n\n\nLogger.log_info\n\n Logger.log_info (message, entity_id:Optional[str]=None,\n                  domo_instance:Optional[str]=None, debug_log=False,\n                  num_stacks_to_drop=3)\n\nlog an informational message\n\nlogger = Logger(app_name=\"test\", output_fn=custom_write_logs_fn)\n\n\ndef test_log():\n    return logger.log_info(\"test the error returns type Info\", debug_log=False)\n\n\ntest_log()\n\n{'date_time': datetime.datetime(2023, 1, 27, 22, 15, 12, 972238),\n 'application': 'test',\n 'log_type': 'Info',\n 'log_message': 'test the error returns type Info',\n 'breadcrumb': '',\n 'domo_instance': None,\n 'entity_id': None,\n 'function_name': 'test_log',\n 'file_name': '/tmp/ipykernel_12636/360630086.py',\n 'function_trail': '<module> -> test_log'}"
  },
  {
    "objectID": "client/logger.html#outputting-logs",
    "href": "client/logger.html#outputting-logs",
    "title": "Logger",
    "section": "Outputting Logs",
    "text": "Outputting Logs\nDuring Logger instantiation, users can pass a function, output_fn which will be called with the Logger.output_log method\n\nsource\n\nLogger.output_log\n\n Logger.output_log ()\n\ncalls the user defined output function\n\nSample implementation with a custom write_logs method\n\nimport pandas as pd\n\ndef custom_write_logs_fn(logs):\n    print(\"printing logs\")\n    return pd.DataFrame(logs)\n\n\nlogger = Logger(app_name=\"test\", output_fn=custom_write_logs_fn)\n\n\ndef test_error():\n    try:\n        if 1 == 1:\n            raise Exception(\"random error\")\n\n    except Exception as e:\n        logger.log_error(e)\n\n\ndef double_test():\n    test_error()\n\n\n# record first error\ntest_error()\n\n# records second error nested inside double_test()\ndouble_test()\n\nlogger.output_log()\n\nprinting logs\n\n\n\n\n\n\n  \n    \n      \n      date_time\n      application\n      log_type\n      log_message\n      breadcrumb\n      domo_instance\n      entity_id\n      function_name\n      file_name\n      function_trail\n    \n  \n  \n    \n      0\n      2023-03-17 01:43:19.458133\n      test\n      Error\n      random error\n      \n      None\n      None\n      test_error\n      <ipython-input-1-235f75018073>\n      <module> -> test_error\n    \n    \n      1\n      2023-03-17 01:43:19.458308\n      test\n      Error\n      random error\n      \n      None\n      None\n      test_error\n      <ipython-input-1-235f75018073>\n      <module> -> double_test -> test_error"
  },
  {
    "objectID": "client/get_data.html",
    "href": "client/get_data.html",
    "title": "get_data",
    "section": "",
    "text": "source"
  },
  {
    "objectID": "client/get_data.html#aiohttp-looper-deprecated",
    "href": "client/get_data.html#aiohttp-looper-deprecated",
    "title": "get_data",
    "section": "Aiohttp Looper DEPRECATED",
    "text": "Aiohttp Looper DEPRECATED\n\nsource\n\nlooper_aiohttp\n\n looper_aiohttp (auth:domolibrary.client.DomoAuth.DomoAuth,\n                 session:aiohttp.client.ClientSession, url, offset_params,\n                 arr_fn:<built-infunctioncallable>,\n                 loop_until_end:bool=False, method='POST', body:dict=None,\n                 fixed_params:dict=None, offset_params_in_body:bool=False,\n                 body_fn=None, limit=1000, skip=0, maximum=2000,\n                 debug_api:bool=False, debug_loop:bool=False)"
  },
  {
    "objectID": "client/responsegetdata.html",
    "href": "client/responsegetdata.html",
    "title": "ResponseGetData",
    "section": "",
    "text": "source\n\n\n\n BlockedByVPN (domo_instance:Optional[str]=None, ip_address:str=None,\n               function_name:str='get_data')\n\nbase exception\n\nsource\n\n\n\n\n ResponseGetData (status:int, response:<built-infunctionany>,\n                  is_success:bool, auth:dict=None)\n\npreferred response class for all API Requests\n\nrgd = ResponseGetData(status=200, response=\"test\", is_success=True)\nrgd\n\nResponseGetData(status=200, response='test', is_success=True)"
  },
  {
    "objectID": "client/responsegetdata.html#requests-library",
    "href": "client/responsegetdata.html#requests-library",
    "title": "ResponseGetData",
    "section": "Requests Library",
    "text": "Requests Library\n\nsource\n\nResponseGetData._from_requests_response\n\n ResponseGetData._from_requests_response (res:requests.models.Response)\n\nreturns ResponseGetData\n\n\n\n\nType\nDetails\n\n\n\n\nres\nResponse\nrequests response object\n\n\nReturns\nResponseGetData\n\n\n\n\n\n# test _from_requests_response returns ResponseGetData class\nimport os\nimport requests\n\nurl = f\"https://domo-dojo.domo.com/api/content/v2/authentication\"\n\ntokenHeaders = {\"Content-Type\": \"application/json\"}\n\nbody = {\n    \"method\": \"password\",\n    \"emailAddress\": \"jae@onyxreporting.com\",\n    \"password\": os.environ[\"DOJO_PASSWORD\"],\n}\n\nres = requests.request(method=\"POST\", url=url, json=body, headers=tokenHeaders)\n\nprint(res.status_code)\n\ntest_res = ResponseGetData._from_requests_response(res)\ntest_res.__dict__.keys()\n\n200\n\n\ndict_keys(['status', 'response', 'is_success', 'auth'])"
  },
  {
    "objectID": "client/responsegetdata.html#httpx-library",
    "href": "client/responsegetdata.html#httpx-library",
    "title": "ResponseGetData",
    "section": "HTTPX Library",
    "text": "HTTPX Library\n\nsource\n\nfind_ip\n\n find_ip (html, html_tag:str='p')"
  },
  {
    "objectID": "client/responsegetdata.html#asyncio-response-handling",
    "href": "client/responsegetdata.html#asyncio-response-handling",
    "title": "ResponseGetData",
    "section": "Asyncio Response Handling",
    "text": "Asyncio Response Handling\n\nsource\n\nResponseGetData._from_aiohttp_response\n\n ResponseGetData._from_aiohttp_response\n                                         (res:aiohttp.client_reqrep.Client\n                                         Response, auth:Optional[<built-\n                                         infunctionany>]=None,\n                                         process_stream:bool=False,\n                                         stream_chunks:int=10,\n                                         debug_api:bool=False,\n                                         response_file_name:str=None)\n\nasync method returns ResponseGetData\n\n# test _from_aiohttp_response returns ResponseGetData class\n\nimport os\nimport requests\n\nurl = f\"https://domo-dojo.domo.com/api/content/v2/authentication\"\n\nbody = {\n    \"method\": \"password\",\n    \"emailAddress\": \"jae@onyxreporting.com\",\n    \"password\": os.environ[\"DOJO_PASSWORD\"],\n}\n\nsession = aiohttp.ClientSession()\nres = await session.post(url=url, json=body)\nawait session.close()\n\nprint(res.status)\n\ntest_res = await ResponseGetData._from_aiohttp_response(res)\ntest_res.__dict__.keys()\n\n200\n\n\ndict_keys(['status', 'response', 'is_success', 'auth'])"
  },
  {
    "objectID": "classes/domopage.html",
    "href": "classes/domopage.html",
    "title": "Page",
    "section": "",
    "text": "source\n\nDomoPage\n\n DomoPage (id:str, title:str=None, parent_page_id:str=None,\n           auth:domolibrary.client.DomoAuth.DomoAuth=None,\n           owners:list=<factory>, cards:list=<factory>,\n           collections:list=<factory>, children:list=<factory>)\n\n\nimport os\nimport domolibrary.routes.bootstrap as bootstrap_routes\n\nauth = dmda.DomoFullAuth(\n    domo_instance='domo-dojo', domo_password = os.environ['DOJO_PASSWORD'], domo_username = 'jae@onyxreporting.com')\n\nres = await bootstrap_routes.get_bootstrap_pages(auth = auth)\n\npage_obj = res.response[10]\nDomoPage._from_bootstrap(page_obj, auth = auth)\n\nDomoPage(id='790951325', title='Coronavirus (COVID-19) Dashboard', parent_page_id=None, owners=[DomoUser(id='1345408759', display_name='Alexis Lorenz (DataMaven)', email_address=None, role_id=None, publisher_domain=None, subscriber_domain=None, virtual_user_id=None)], cards=[], collections=[], children=[DomoPage(id='1289295627', title='Dataset Schemas', parent_page_id=None, owners=[DomoUser(id='1345408759', display_name='Alexis Lorenz (DataMaven)', email_address=None, role_id=None, publisher_domain=None, subscriber_domain=None, virtual_user_id=None)], cards=[], collections=[], children=[]), DomoPage(id='756869253', title='Coronavirus (Alexis)', parent_page_id=None, owners=[DomoUser(id='1345408759', display_name='Alexis Lorenz (DataMaven)', email_address=None, role_id=None, publisher_domain=None, subscriber_domain=None, virtual_user_id=None)], cards=[], collections=[], children=[]), DomoPage(id='11555470', title='Contiguous United States Detail (Alexis)', parent_page_id=None, owners=[DomoUser(id='1345408759', display_name='Alexis Lorenz (DataMaven)', email_address=None, role_id=None, publisher_domain=None, subscriber_domain=None, virtual_user_id=None)], cards=[], collections=[], children=[])])\n\n\n\n# @classmethod\n#     async def get_from_id(cls, page_id: str, full_auth: DomoFullAuth, debug: bool = False):\n#         import Library.DomoClasses.DomoCard as dc\n#         res = await page_routes.get_page_by_id(full_auth=full_auth, page_id=page_id, debug=debug)\n\n#         if res.status == 200:\n#             dd = DictDot(res.response)\n\n#             pg = cls(\n#                 id=dd.id,\n#                 domo_instance=full_auth.domo_instance,\n#                 title=dd.title,\n#                 parent_page_id=dd.page.parentPageId,\n#                 owners=dd.page.owners,\n#                 collections=dd.collections\n#             )\n\n#             pg.cards = await asyncio.gather(\n#                 *[dc.DomoCard.get_from_id(id=card.id, full_auth=full_auth) for card in dd.cards])\n\n#             return pg\n\n#     @classmethod\n#     async def get_cards(cls, full_auth, page_id, debug: bool = False, session: httpx.AsyncClient = None):\n#         try:\n#             import Library.DomoClasses.DomoCard as dc\n#             close_session = False if session else True\n\n#             if not session:\n#                 session = httpx.AsyncClient()\n\n#             res = await page_routes.get_page_definition(full_auth=full_auth, page_id=page_id, debug=debug, session=session)\n\n#             if res.status == 200:\n#                 json = res.response\n\n#                 card_list = [dc.DomoCard(id=card.get(\n#                     'id'), full_auth=full_auth) for card in json.get('cards')]\n\n#                 return card_list\n\n#             else:\n#                 return None\n\n#         finally:\n#             if close_session:\n#                 await session.aclose()\n\n#     async def get_datasets(full_auth, page_id, debug: bool = False, session: httpx.AsyncClient = None):\n#         try:\n#             import Library.DomoClasses.DomoDataset as dmds\n#             close_session = False if session else True\n\n#             if not session:\n#                 session = httpx.AsyncClient()\n\n#             res = await page_routes.get_page_definition(full_auth=full_auth, page_id=page_id, debug=debug, session=session)\n\n#             if res.status == 200:\n#                 json = res.response\n\n#                 dataset_ls = [card.get('datasources')\n#                               for card in json.get('cards')]\n\n#                 return [dmds.DomoDataset(id=ds.get('dataSourceId'), full_auth=full_auth) for ds_ls in dataset_ls for ds in ds_ls]\n\n#             else:\n#                 return None\n\n#         finally:\n#             if close_session:\n#                 await session.aclose()"
  },
  {
    "objectID": "classes/domoaccount.html",
    "href": "classes/domoaccount.html",
    "title": "Account",
    "section": "",
    "text": "Each Domo Dataset that pulls data into Vault must have a stream, which stores the configuration information related to which data is exctracted from a datasource. Each stream has an associated account which stores the source data’s authentication information.\nBecause each datasource may have different authentication parameters, there may be multiple versions of the same account type (with different credentials) or multiple account types deployed within a domo instance if the user is extracting data from multiple systems.\nAccount’s can be configured such that certain fields are designated as encrypted fields, and the user will never be able to see the encrypted values EXCEPT in Domo’s Jupyter Notebook integration.\n\nsource\n\n\n\n DomoAccount_Config ()\n\nDomoAccount Config abstract base class\n\nsource\n\n\n\n\n DomoAccount_Config_AbstractCredential (credentials:dict)\n\n\nsource\n\n\n\n\n DomoAccount_Config_DatasetCopy (domo_instance:str, access_token:str)\n\n\nsource\n\n\n\n\n DomoAccount_Config_Governance (domo_instance:str, access_token:str)\n\n\nsource\n\n\n\n\n DomoAccount_Config_HighBandwidthConnector (aws_access_key:str,\n                                            aws_secret_key:str,\n                                            s3_staging_dir:str,\n                                            region:str='us-west-2')\n\n\nsource\n\n\n\n\n DomoAccount_Config_AwsAthena (aws_access_key:str, aws_secret_key:str,\n                               s3_staging_dir:str, workgroup:str,\n                               region:str='us-west-2')\n\n\nsource\n\n\n\n\n AccountConfig (value, names=None, module=None, qualname=None, type=None,\n                start=1)\n\nEnum provides appropriate spelling for data_provider_type and config object. The name of the enum should correspond with the data_provider_type with hyphens replaced with underscores."
  },
  {
    "objectID": "classes/domoaccount.html#account-metadata-and-configuration",
    "href": "classes/domoaccount.html#account-metadata-and-configuration",
    "title": "Account",
    "section": "Account Metadata and Configuration",
    "text": "Account Metadata and Configuration\n\nsource\n\nDomoAccount.update_config\n\n DomoAccount.update_config\n                            (auth:domolibrary.client.DomoAuth.DomoAuth=Non\n                            e, debug_api:bool=False,\n                            config:__main__.DomoAccount_Config=None,\n                            session:httpx.AsyncClient=None,\n                            return_raw:bool=False)\n\n\nSample implementation of update_config\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ndomo_instance = \"domo-dojo\"\naccess_token = os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n\n# creates a DomoAccount object\ndomo_account = await DomoAccount.get_from_id(auth=token_auth, account_id=5)\n\n\n# update domo Account API without passing explicit config object\n# adjust configuration information for that object\ndomo_account.config.domo_instance = \"domo-dojo\"\ndomo_account.config.access_token = os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\nawait domo_account.update_config()\n\n# update domo Account API by passing new config object\nconfig = AccountConfig.domo_governance_d14c2fef_49a8_4898_8ddd_f64998005600.value(\n    domo_instance=domo_instance, access_token=access_token\n)\nawait domo_account.update_config(config=config)\n\nDomoAccount(name='test_rename', data_provider_type='domo-governance-d14c2fef-49a8-4898-8ddd-f64998005600', id=5, created_dt=datetime.datetime(2021, 3, 26, 16, 54, 41), modified_dt=datetime.datetime(2023, 3, 17, 1, 39, 21), config=DomoAccount_Config_Governance(domo_instance='domo-dojo'))\n\n\n\nsource\n\n\n\nDomoAccount.update_name\n\n DomoAccount.update_name (account_name:str=None,\n                          auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                          debug_api:bool=False,\n                          session:httpx.AsyncClient=None,\n                          return_raw:bool=False)\n\n\nsource\n\n\nDomoAccount_UpdateName_Error\n\n DomoAccount_UpdateName_Error (domo_instance, status, message, entity_id,\n                               function_name='update_name')\n\nbase exception\n\nsample implementation of update_name\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\n# creates a DomoAccount object\ndomo_account = await DomoAccount.get_from_id(auth=token_auth, account_id=5)\n\naccount_name = \"test_rename\"\n\n# update domo Account API without passing explicit config object\n# adjust configuration information for that object\ndomo_account.name = account_name\n# await domo_account.update_name()\n\n# update domo Account API by passing account_name str\nawait domo_account.update_name(account_name=account_name, return_raw=False)\n\nDomoAccount(name='test_rename', data_provider_type='domo-governance-d14c2fef-49a8-4898-8ddd-f64998005600', id=5, created_dt=datetime.datetime(2021, 3, 26, 16, 54, 41), modified_dt=datetime.datetime(2023, 3, 17, 1, 43, 27), config=DomoAccount_Config_Governance(domo_instance='domo-dojo'))"
  },
  {
    "objectID": "classes/domoaccount.html#create-account",
    "href": "classes/domoaccount.html#create-account",
    "title": "Account",
    "section": "Create Account",
    "text": "Create Account\n\nsource\n\nDomoAccount_CreateAccount_Error\n\n DomoAccount_CreateAccount_Error (entity_id, domo_instance, status,\n                                  message, function_name='create_account')\n\nbase exception\n\nsource\n\n\nDomoAccount.create_account\n\n DomoAccount.create_account (account_name:str,\n                             config:__main__.DomoAccount_Config,\n                             auth:domolibrary.client.DomoAuth.DomoAuth,\n                             debug_api:bool=False,\n                             session:httpx.AsyncClient=None)\n\n\nsource\n\n\nDomoAccount.generate_create_body\n\n DomoAccount.generate_create_body (account_name, config)\n\n\nsource\n\n\nDomoAccount.delete_account\n\n DomoAccount.delete_account\n                             (auth:domolibrary.client.DomoAuth.DomoAuth=No\n                             ne, debug_api:bool=False,\n                             session:httpx.AsyncClient=None)\n\n\nsource\n\n\nDomoAccount_DeleteAccount_Error\n\n DomoAccount_DeleteAccount_Error (entity_id, domo_instance, status,\n                                  message, function_name='delete_account')\n\nbase exception\n\nsource\n\n\nDomoAccount.share_account\n\n DomoAccount.share_account (auth:domolibrary.client.DomoAuth.DomoAuth,\n                            user_id:int, is_v2:bool=False, access_level:__\n                            main__.ShareAccount_AccessLevel=<ShareAccount_\n                            AccessLevel.CAN_VIEW: 'CAN_VIEW'>,\n                            debug_api:bool=False,\n                            session:httpx.AsyncClient=None)\n\n\nsource\n\n\nShareAccount_AccessLevel\n\n ShareAccount_AccessLevel (value, names=None, module=None, qualname=None,\n                           type=None, start=1)\n\nenumerates access levels for Domo Users and Domo Accounts"
  },
  {
    "objectID": "classes/domodataset.html",
    "href": "classes/domodataset.html",
    "title": "Dataset",
    "section": "",
    "text": "The DomoDataset_Schema class will be a subclass of DomoDataset. It will handle all of the methods for interacting with schemas.\n\nIn execution, the schema is separate from the data that gets uploaded from Vault to Adrenaline. The domo schema defines how the data is loaded into Vault.\nBe cognizant to match dataset uploads with schema definitions. If the schema and uploaded data types do not match, the dataset may be unable to index in Adrenaline (and therefore not update).\n\n\nsource\n\n\n\n DomoDataset_Schema (dataset:<built-infunctionany>=None,\n                     columns:List[__main__.DomoDataset_Schema_Column]=<fac\n                     tory>)\n\nclass for interacting with dataset schemas\n\nsource\n\n\n\n\n DomoDataset_Schema_Column (name:str, id:str,\n                            type:__main__.DatasetSchema_Types)\n\n\nsource\n\n\n\n\n DatasetSchema_Types (value, names=None, module=None, qualname=None,\n                      type=None, start=1)\n\nAn enumeration.\n\nsource\n\n\n\n\n DomoDataset_Schema.get\n                         (auth:Optional[domolibrary.client.DomoAuth.DomoAu\n                         th]=None, dataset_id:str=None,\n                         debug_api:bool=False, return_raw_res:bool=False)\n\nmethod that retrieves schema for a dataset\n\n\nStandard implementation will be to access the DomoDataset_Schema class as the DomoDataset.schema property\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_schema = DomoDataset_Schema()\n\nawait ds_schema.get(auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"])\n\n[DomoDataset_Schema_Column(name='objectID', id='objectID', type='STRING'),\n DomoDataset_Schema_Column(name='url', id='url', type='STRING'),\n DomoDataset_Schema_Column(name='Title', id='Title', type='STRING'),\n DomoDataset_Schema_Column(name='article', id='article', type='STRING'),\n DomoDataset_Schema_Column(name='views', id='views', type='LONG'),\n DomoDataset_Schema_Column(name='created_dt', id='created_dt', type='DATETIME'),\n DomoDataset_Schema_Column(name='published_dt', id='published_dt', type='DATETIME')]\n\n\n\n\n\n\n\n\nsource\n\n\n\n DomoDataset_Tags (dataset:<built-infunctionany>=None,\n                   tag_ls:List[str]=<factory>)\n\nclass for interacting with dataset tags\n\nsource\n\n\n\n\n DatasetTags_SetTagsError (dataset_id, domo_instance)\n\nreturn if DatasetTags request is not successfull\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_tag = DomoDataset_Tags()\nawait ds_tag.get(auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"])\n\n['developer_documentation', 'hackercore']\n\n\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntoday = dt.datetime.now().strftime(\"%b-%d-%Y %H:%M\")\n\nds_tag = DomoDataset_Tags()\n\nawait ds_tag.set(\n    auth=token_auth,\n    dataset_id=os.environ[\"DOJO_DATASET_ID\"],\n    tag_ls=[\"developer_documentation\", \"hackercore\", today],\n)\n\n['Mar-17-2023 01:43', 'developer_documentation', 'hackercore']\n\n\n\nsource\n\n\n\n\n DomoDataset_Tags.add (add_tag_ls:[<class'str'>], dataset_id:str=None,\n                       auth:Optional[domolibrary.client.DomoAuth.DomoAuth]\n                       =None, debug_api:bool=False,\n                       session:Optional[httpx.AsyncClient]=None)\n\nappends tags to the list of existing dataset_tags\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntoday_year = dt.datetime.today().strftime(\"%Y\")\nds_tag = DomoDataset_Tags()\nawait ds_tag.add(\n    auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"], add_tag_ls=[today_year]\n)\n\n['Mar-17-2023 01:43', '2023', 'developer_documentation', 'hackercore']\n\n\n\nsource\n\n\n\n\n DomoDataset_Tags.remove (remove_tag_ls:[<class'str'>],\n                          dataset_id:str=None, auth:domolibrary.client.Dom\n                          oAuth.DomoFullAuth=None, debug_api:bool=False,\n                          session:Optional[httpx.AsyncClient]=None)\n\nremoves tags from the existing list of dataset_tags\n\n\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntoday_year = dt.datetime.today().strftime(\"%Y\")\n\nds_tag = DomoDataset_Tags()\n\nawait ds_tag.remove(\n    auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"], remove_tag_ls=[ today_year])\n\n['Mar-17-2023 01:43', 'developer_documentation', 'hackercore']"
  },
  {
    "objectID": "classes/domodataset.html#upload-data",
    "href": "classes/domodataset.html#upload-data",
    "title": "Dataset",
    "section": "Upload Data",
    "text": "Upload Data\n\nsource\n\nDomoDataset_UploadData_CommitDatasetUploadId_Error\n\n DomoDataset_UploadData_CommitDatasetUploadId_Error (domo_instance:str,\n                                                     dataset_id:str,\n                                                     stage:int=3,\n                                                     status='', reason='',\n                                                     partition_key:str=Non\n                                                     e)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nDomoDataset_UploadData_UploadData_Error\n\n DomoDataset_UploadData_UploadData_Error (domo_instance:str,\n                                          dataset_id:str, stage:int=2,\n                                          status='', reason='',\n                                          partition_key:str=None)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nDomoDataset_UploadData_DatasetUploadId_Error\n\n DomoDataset_UploadData_DatasetUploadId_Error (domo_instance:str,\n                                               dataset_id:str,\n                                               stage:int=1, status='',\n                                               reason='',\n                                               partition_key:str=None)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nDomoDataset_UploadData_Error\n\n DomoDataset_UploadData_Error (message_error:str, domo_instance:str,\n                               dataset_id:str, stage:int, status='',\n                               reason='', partition_key:str=None)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nDomoDataset.index_dataset\n\n DomoDataset.index_dataset\n                            (auth:domolibrary.client.DomoAuth.DomoAuth=Non\n                            e, dataset_id:str=None, debug_api:bool=False,\n                            session:httpx.AsyncClient=None)\n\n\nsource\n\n\nDomoDataset.upload_data\n\n DomoDataset.upload_data (upload_df:pandas.core.frame.DataFrame=None,\n                          upload_df_ls:list[pandas.core.frame.DataFrame]=N\n                          one, upload_file:_io.TextIOWrapper=None,\n                          upload_method:str='REPLACE',\n                          partition_key:str=None, is_index:bool=True,\n                          dataset_id:str=None, dataset_upload_id=None,\n                          auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                          session:httpx.AsyncClient=None,\n                          debug_api:bool=False, debug_prn:bool=False)"
  },
  {
    "objectID": "classes/domodataset.html#partitions",
    "href": "classes/domodataset.html#partitions",
    "title": "Dataset",
    "section": "Partitions",
    "text": "Partitions\n\nsource\n\nDomoDataset.list_partitions\n\n DomoDataset.list_partitions\n                              (auth:domolibrary.client.DomoAuth.DomoAuth=N\n                              one, dataset_id:str=None,\n                              debug_api:bool=False,\n                              session:httpx.AsyncClient=None)\n\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ndataset_id = 'd2b21660-4ba8-400c-badf-aeef5a9abae1'\n\nds = await DomoDataset.get_from_id(auth=token_auth, dataset_id=dataset_id)\nds_partition_ls = await ds.list_partitions()\n\npd.DataFrame(ds_partition_ls[0:5])\n\n\n\n\n\n  \n    \n      \n      dataId\n      partitionId\n      dateCompleted\n      rowCount\n    \n  \n  \n    \n      0\n      372\n      2013-07-02\n      2023-01-24T14:27:21.000+00:00\n      1\n    \n    \n      1\n      373\n      2013-07-01\n      2023-01-24T14:27:21.000+00:00\n      1\n    \n    \n      2\n      354\n      2013-07-20\n      2023-01-24T14:27:20.000+00:00\n      1\n    \n    \n      3\n      355\n      2013-07-19\n      2023-01-24T14:27:20.000+00:00\n      1\n    \n    \n      4\n      356\n      2013-07-18\n      2023-01-24T14:27:20.000+00:00\n      1\n    \n  \n\n\n\n\n\nsource\n\n\nDomoDataset.create\n\n DomoDataset.create (dataset_name:str, dataset_type='api', schema=None,\n                     auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                     debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nsource\n\n\nDomoDataset_CreateDataset_Error\n\n DomoDataset_CreateDataset_Error (domo_instance:str, dataset_name:str,\n                                  status:int, reason:str)\n\nCommon base class for all non-exit exceptions.\n\nsample implementation of create dataset\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\n# await DomoDataset.create( dataset_name= 'Hello world_v2', dataset_type='API', auth = token_auth, debug_api = False)\n\n\n#     async def delete_partition(self,\n#                                dataset_partition_id: str,\n\n#                                dataset_id: str = None,\n#                                empty_df: pd.DataFrame = None,\n\n#                                auth: DomoFullAuth = None,\n\n#                                is_index: bool = True,\n#                                debug_api: bool = False,\n#                                session: httpx.AsyncClient = None):\n\n#         is_close_session = True if not session else False\n\n#         session = session or httpx.AsyncClient()\n#         auth = auth or self.auth\n#         dataset_id = dataset_id or self.id\n\n# #        if empty_df is None:\n# #            empty_df = await self.query_dataset_private(auth=auth,\n# #                                                        dataset_id=dataset_id,\n# #                                                        sql=\"SELECT * from table limit 1\",\n# #                                                        debug=False)\n# #\n# #        await self.upload_csv(upload_df=empty_df.head(0),\n# #                              upload_method='REPLACE',\n# #                              is_index=is_index,\n# #                              partition_key=dataset_partition_id,\n# #                              session=session,\n# #                              debug=False)\n#         if debug_api:\n#             print(f\"\\n\\n🎭 starting Stage 1\")\n\n#         res = await dataset_routes.delete_partition_stage_1(auth=auth,\n#                                                             dataset_id=dataset_id,\n#                                                             dataset_partition_id=dataset_partition_id,\n#                                                             debug=debug, session=session)\n#         if debug_api:\n#             print(f\"\\n\\n🎭 Stage 1 response -- {res.status}\")\n#             print(res)\n\n#         stage_2_res = None\n#         if debug_api:\n#             print('starting Stage 2')\n#         stage_2_res = await dataset_routes.delete_partition_stage_2(auth=auth,\n#                                                                     dataset_id=dataset_id,\n#                                                                     dataset_partition_id=dataset_partition_id,\n#                                                                     debug=debug, session=session)\n#         if debug_api:\n#             print(f\"\\n\\n🎭 Stage 2 response -- {stage_2_res.status}\")\n\n#         stage_3_res = None\n#         if debug_api:\n#             print('starting Stage 3')\n#         stage_3_res = await dataset_routes.index_dataset(auth=auth,\n#                                                          dataset_id=dataset_id,\n#                                                          debug=debug, session=session)\n#         if debug_api:\n#             print(f\"\\n\\n🎭 Stage 3 response -- {stage_3_res.status}\")\n\n#         if is_close_session:\n#             await session.aclose()\n\n#         if debug_api:\n#             print(stage_3_res)\n\n#         if stage_3_res.status == 200:\n#             return res.response\n\n\n#     async def reset_dataset(self,\n#                             auth: DomoFullAuth = None,\n#                             is_index: bool = True,\n#                             debug_api: bool = False\n#                             ):\n#         execute_reset = input(\n#             \"This function will delete all rows.  Type BLOW_ME_AWAY to execute:\")\n\n#         if execute_reset != 'BLOW_ME_AWAY':\n#             print(\"You didn't type BLOW_ME_AWAY, moving on.\")\n#             return None\n\n#         auth = auth or self.auth\n#         dataset_id = self.id\n\n#         if not auth:\n#             raise Exception(\"auth required\")\n\n#         session = httpx.AsyncClient()\n\n#         # create empty dataset to retain schema\n#         empty_df = await self.query_dataset_private(auth=auth,\n#                                                     dataset_id=dataset_id,\n#                                                     sql=\"SELECT * from table limit 1\",\n#                                                     session=session,\n#                                                     debug=debug)\n#         empty_df = empty_df.head(0)\n\n#         # get partition list\n# #         partition_list = await dataset_routes.list_partitions(auth=auth,\n# #                                                               dataset_id=self.id,\n# #                                                               debug=debug,\n# #                                                               session=session)\n\n# #         if len(partition_list) > 0:\n# #             partition_list = chunk_list(partition_list, 100)\n\n# #             for index, pl in enumerate(partition_list):\n# #                 print(f'🥫 starting chunk {index + 1} of {len(partition_list)}')\n\n# #                 await asyncio.gather(*[self.delete_partition(auth=auth,\n# #                                                              dataset_partition_id=partition.get('partitionId'),\n# #                                                              session=session,\n# #                                                              empty_df=empty_df,\n# #                                                              debug=False) for partition in pl])\n# #                 if is_index:\n# #                     await self.index_dataset(session=session)\n\n#         res = await self.upload_csv(upload_df=empty_df,\n#                                     upload_method='REPLACE',\n#                                     is_index=is_index,\n#                                     session=session,\n#                                     debug=False)\n\n#         await session.aclose()\n#         return True"
  },
  {
    "objectID": "classes/domobootstrap.html",
    "href": "classes/domobootstrap.html",
    "title": "Bootstrap",
    "section": "",
    "text": "source\n\nDomoBootstrap_Feature\n\n DomoBootstrap_Feature (id:int, name:str, label:str, type:str,\n                        purchased:bool, enabled:bool)\n\n\nsource\n\n\nDomoBootstrap\n\n DomoBootstrap (auth:domolibrary.client.DomoAuth.DomoAuth,\n                page_ls:list[domolibrary.classes.DomoPage.DomoPage]=None,\n                feature_ls:list[__main__.DomoBootstrap_Feature]=None)\n\n\nsource\n\n\nDomoBootstrap.get_all\n\n DomoBootstrap.get_all (auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                        debug_api:bool=False)\n\n\nsample implementation of get_all\n\nimport os\n\nfull_auth = dmda.DomoFullAuth(\n    domo_instance='domo-dojo', domo_password = os.environ['DOJO_PASSWORD'], domo_username = 'jae@onyxreporting.com')\n\nbs = DomoBootstrap( auth = full_auth)\n\nbsr = await bs.get_all()\nbsr.keys()\n\ndict_keys(['notifierConfig', 'currentUser', 'data'])\n\n\n\nsource\n\n\n\nDomoBootstrap.get_pages\n\n DomoBootstrap.get_pages (auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                          return_raw:bool=False, debug_api:bool=False)\n\n\nsample implementation of get_pages\n\nimport os\nimport pandas as pd\n\nfull_auth = dmda.DomoFullAuth(\n    domo_instance='domo-dojo', \n    domo_password=os.environ['DOJO_PASSWORD'],\n    domo_username='jae@onyxreporting.com')\n\nbs = DomoBootstrap(auth=full_auth)\n\npage_ls = await bs.get_pages(return_raw = False)\n\n# bs.page_ls\npd.DataFrame(page_ls[10:14]).drop(columns = ['auth'] )\n\nDictDot(id=1814479647, type='GROUP', displayName='Admin Test')\n\n\n\n\n\n\n  \n    \n      \n      id\n      title\n      parent_page_id\n      owners\n      cards\n      collections\n      children\n    \n  \n  \n    \n      0\n      790951325\n      Coronavirus (COVID-19) Dashboard\n      None\n      [{'id': '1345408759', 'display_name': 'Alexis ...\n      []\n      []\n      [{'id': '1289295627', 'title': 'Dataset Schema...\n    \n    \n      1\n      1891382078\n      Fun Stuff\n      None\n      [{'id': '1345408759', 'display_name': 'Alexis ...\n      []\n      []\n      [{'id': '1124898205', 'title': 'Quotes', 'pare...\n    \n    \n      2\n      545237196\n      Demo Apps\n      None\n      [{'id': '826020125', 'display_name': 'Ritwik',...\n      []\n      []\n      []\n    \n    \n      3\n      400620119\n      Data Science Workshop\n      None\n      [{'id': '1504505648', 'display_name': 'Ken Lor...\n      []\n      []\n      []\n    \n  \n\n\n\n\n\nsource\n\n\n\nDomoBootstrap.get_features\n\n DomoBootstrap.get_features\n                             (auth:domolibrary.client.DomoAuth.DomoAuth=No\n                             ne, debug_api:bool=False,\n                             return_raw:bool=False,\n                             session:httpx.AsyncClient=None)\n\n\nimport os\nimport pandas as pd\n\nfull_auth = dmda.DomoFullAuth(\n    domo_instance='domo-dojo',\n    domo_password=os.environ['DOJO_PASSWORD'],\n    domo_username='jae@onyxreporting.com')\n\nbs = DomoBootstrap(auth=full_auth)\n\nfeature_ls = await bs.get_features(return_raw=False)\n\npd.DataFrame(feature_ls[10:14])\n\n\n\n\n\n  \n    \n      \n      id\n      name\n      label\n      type\n      purchased\n      enabled\n    \n  \n  \n    \n      0\n      3440\n      admin-pages\n      \n      PREMIUM\n      True\n      True\n    \n    \n      1\n      3441\n      admin-slideshows\n      \n      PREMIUM\n      True\n      True\n    \n    \n      2\n      3442\n      admin-access-rights\n      \n      PREMIUM\n      True\n      True\n    \n    \n      3\n      3443\n      admin-tool-downloads\n      \n      PREMIUM\n      True\n      True"
  },
  {
    "objectID": "classes/domodataflow.html",
    "href": "classes/domodataflow.html",
    "title": "Dataflow",
    "section": "",
    "text": "sample implementation of DataFlow_Action\nNote: this list of properties that can be attached to DomoDataflow_Action is by no means comprehensive. To capture more data from the API, simply add properties to the class and extend the DomoDataflow_Action._from_obj private method.\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await dataflow_routes.get_dataflow_by_id(dataflow_id=70, auth=token_auth)\n\n[ DomoDataflow_Action._from_obj(action).__dict__\n for action in res.response.get('actions')]\n\n[{'type': 'LoadFromVault',\n  'id': '241025d7-3cca-4369-b7c0-b3264277c0e1',\n  'name': 'domostats_people',\n  'data_source_id': '241025d7-3cca-4369-b7c0-b3264277c0e1',\n  'sql': None},\n {'type': 'GenerateTableAction',\n  'id': 'c176aa53-122a-4a2e-8b6f-41ca4a72d67c',\n  'name': 't_1',\n  'data_source_id': None,\n  'sql': 'SELECT\\n`Display Name`,\\n`User ID`\\n, @row := @row+1 as id\\n, @isReset := case when @iter = @rowCounter then 1 else 0 end isReset\\n, @group := @isReset + @group   as rowGroup\\n, @iter := case when @isReset = 1 then 1 else @iter + 1 end iter\\n, @rowCounter := case when @isReset = 1 then FLOOR( RAND() * (7-3) + 3) else @rowCounter end numChildren\\n\\n\\nfrom `domostats_people` p\\n\\n, (select @row:= 0,@rowCounter:= 1, @iter := 1, @isReset := 0 , @group := 0) r'},\n {'type': 'GenerateTableAction',\n  'id': 'ac9f630d-d865-4925-b955-4316e227229a',\n  'name': 'reportsto',\n  'data_source_id': None,\n  'sql': \"\\nselect  b.`User ID` as userID , 'reportsTo' as Action , a.`User ID` as bodyID\\n\\nfrom t_1 a \\n\\njoin t_1 b \\n\\non a.id = b.`rowGroup`\\nwhere a.`User ID` <> b.`User ID`\\n\\nUNION\\n\\nselect  b.`User ID` as userID , 'directReports' as Action , a.`User ID` as bodyID\\n\\nfrom t_1 a \\n\\njoin t_1 b \\n\\non b.id = a.`rowGroup`\\n\\nwhere a.`User ID` <> b.`User ID`\\n\\n\"},\n {'type': 'PublishToVault',\n  'id': '8edc3d78-3586-47a8-9775-c7b146a50d19',\n  'name': 'domoStats_people_reports',\n  'data_source_id': 'd9257748-c181-496e-8f9a-016ee99b4a14',\n  'sql': 'select * from `reportsto`'}]\n\n\n\nsource\n\n\nDomoDataflow\n\n DomoDataflow (id:str, name:str,\n               auth:domolibrary.client.DomoAuth.DomoAuth=None,\n               owner:str=None, description:str=None, tags:list[str]=None,\n               actions:list[__main__.DomoDataflow_Action]=None,\n               action:list[__main__.DomoDataflow_Action]=None)\n\n\nsource\n\n\nDomoDataflow.get_from_id\n\n DomoDataflow.get_from_id (dataflow_id:int,\n                           auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                           debug_api:bool=False, return_raw:bool=False)\n\n\nsample implementation of get_from_id\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"])\n\nawait DomoDataflow.get_from_id(dataflow_id = 70, auth = token_auth)\n\nDomoDataflow(id=70, name='DomoStats - people - reports', auth=DomoTokenAuth(domo_instance='domo-dojo', token_name='token_auth', url_manual_login='https://domo-dojo.domo.com/auth/index?domoManualLogin=true'), owner=None, description=None, tags=None, actions=[DomoDataflow_Action(type='LoadFromVault', id='241025d7-3cca-4369-b7c0-b3264277c0e1', name='domostats_people', data_source_id='241025d7-3cca-4369-b7c0-b3264277c0e1', sql=None), DomoDataflow_Action(type='GenerateTableAction', id='c176aa53-122a-4a2e-8b6f-41ca4a72d67c', name='t_1', data_source_id=None, sql='SELECT\\n`Display Name`,\\n`User ID`\\n, @row := @row+1 as id\\n, @isReset := case when @iter = @rowCounter then 1 else 0 end isReset\\n, @group := @isReset + @group   as rowGroup\\n, @iter := case when @isReset = 1 then 1 else @iter + 1 end iter\\n, @rowCounter := case when @isReset = 1 then FLOOR( RAND() * (7-3) + 3) else @rowCounter end numChildren\\n\\n\\nfrom `domostats_people` p\\n\\n, (select @row:= 0,@rowCounter:= 1, @iter := 1, @isReset := 0 , @group := 0) r'), DomoDataflow_Action(type='GenerateTableAction', id='ac9f630d-d865-4925-b955-4316e227229a', name='reportsto', data_source_id=None, sql=\"\\nselect  b.`User ID` as userID , 'reportsTo' as Action , a.`User ID` as bodyID\\n\\nfrom t_1 a \\n\\njoin t_1 b \\n\\non a.id = b.`rowGroup`\\nwhere a.`User ID` <> b.`User ID`\\n\\nUNION\\n\\nselect  b.`User ID` as userID , 'directReports' as Action , a.`User ID` as bodyID\\n\\nfrom t_1 a \\n\\njoin t_1 b \\n\\non b.id = a.`rowGroup`\\n\\nwhere a.`User ID` <> b.`User ID`\\n\\n\"), DomoDataflow_Action(type='PublishToVault', id='8edc3d78-3586-47a8-9775-c7b146a50d19', name='domoStats_people_reports', data_source_id='d9257748-c181-496e-8f9a-016ee99b4a14', sql='select * from `reportsto`')], action=None)"
  },
  {
    "objectID": "classes/domorole.html",
    "href": "classes/domorole.html",
    "title": "Domo Role",
    "section": "",
    "text": "source"
  },
  {
    "objectID": "classes/domorole.html#handle-role-grants",
    "href": "classes/domorole.html#handle-role-grants",
    "title": "Domo Role",
    "section": "Handle Role Grants",
    "text": "Handle Role Grants\n\nsource\n\nDomoRole.get_grants\n\n DomoRole.get_grants (auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                      role_id:str=None, debug_api:bool=False,\n                      session:httpx.AsyncClient=None,\n                      return_raw:bool=False)\n\n\nsample implementation of get_role_grants\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ndomo_role = DomoRole(auth = token_auth, id = 1)\nawait domo_role.get_grants(return_raw= False)\n\n[DomoGrant(id='versions.deployment.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='buzz.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='dataflow.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='goal.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='dataset.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='workflow.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='profile.achieve.assign', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='datascience.notebooks.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='content.dataapp.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='dataset.export', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='user.invite', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='connector.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='content.card.analyzerview', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='fileshare.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='customer.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='content.variable.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='pipeline.executor.job.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='cloud.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='versions.repository.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='codeengine.package.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='appstore.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='datastore.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='certifiedcontent.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='group.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='tasks.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='group.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='app.ddx', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='queue.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='domoapps.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='content.export', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='codeengine.package.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='domo.system.messages', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='publish.space.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='authorization.roles', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='dataset.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='goal.distribute', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='appstore.read', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='content.card.embed', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='content.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='user.session.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='cloud.override', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='datastore.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='user.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='content.card.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='saasaas.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='developer.token.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='publish.subscribers.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='certifiedcontent.request', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='content.page.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='alert.actions', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='ml.execute', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='audit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='domoapps.read', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='content.card.narrative.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='approvalcenter.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='datascience.notebooks.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='form.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='pipeline.executor.job.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='alert.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='fileshare.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='appstore.payments.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='publish.publication.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='dataflow.adrenaline', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='workbench.download', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='dataset.account.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='usage.reports.view', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='goal.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='versions.repository.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='app.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='dataflow.magic', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='dataflow.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='workflow.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='form.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='queue.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='alert.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='appstore.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None)]\n\n\n\nsource\n\n\n\nDomoRole.set_grants\n\n DomoRole.set_grants\n                      (grant_ls:list[domolibrary.classes.DomoGrant.DomoGra\n                      nt], role_id:str=None,\n                      auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                      debug_api:bool=False)\n\n\nsource\n\n\nSetRoleGrants_MissingGrants\n\n SetRoleGrants_MissingGrants (role_id, missing_grants, domo_instance)\n\nbase exception\n\nsample implementation of set_grants\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ndomo_role = DomoRole(id=104295428, auth=token_auth)\n\nrole_grant_ls = ['cloud.admin', 'versions.repository.admin',\n                 'codeengine.package.manage', 'appstore.admin', 'datastore.admin',\n                 'certifiedcontent.admin']\n\nawait domo_role.set_grants(grant_ls=role_grant_ls)\n\n[DomoGrant(id='cloud.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='versions.repository.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='codeengine.package.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='appstore.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='datastore.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None),\n DomoGrant(id='certifiedcontent.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None)]"
  },
  {
    "objectID": "classes/domorole.html#handle-role-membership",
    "href": "classes/domorole.html#handle-role-membership",
    "title": "Domo Role",
    "section": "Handle Role Membership",
    "text": "Handle Role Membership\n\nsource\n\nDomoRole.get_membership\n\n DomoRole.get_membership (role_id=None,\n                          auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                          return_raw:bool=False, debug_api:bool=False,\n                          session:httpx.AsyncClient=None)\n\n\nsample implementation of get_membership\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ndomo_role = DomoRole(id=1, auth=token_auth)\n\nawait domo_role.get_membership(return_raw=False)\n\n[DomoUser(id='1345408759', display_name='Alexis Lorenz (DataMaven)', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1102391116', display_name='Andrea Henderson', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1095515127', display_name='Andrew Chaffin', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='2074422502', display_name='Bard Higgins', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1865099622', display_name='Ben Schein', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='587894148', display_name='Bryan Van Kampen', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='307632801', display_name='Dan Brinton', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='68216396', display_name='Elliott Leonard', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1026818196', display_name='Giuseppe Russo', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='244750981', display_name='Gordon Pont', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='55874022', display_name='Grant Smith', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='805381129', display_name='Jack Wang', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1893952720', display_name='Jae Wilson1', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1141078945', display_name='Justin Pumford', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='475856860', display_name='Noah Finberg', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='617808774', display_name='Richard Carey', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None)]\n\n\n\nsource\n\n\n\nAddUser_Error\n\n AddUser_Error (role_id, domo_instance, user_id, user_name=None)\n\nbase exception\n\nsource\n\n\nDomoRole.add_user\n\n DomoRole.add_user (user:domolibrary.classes.DomoUser.DomoUser,\n                    role_id:str=None,\n                    auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                    debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nsample implementation of add_user\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ndomo_user = dmu.DomoUser(id = 587894148 , auth = token_auth)\ndomo_role = DomoRole(id=1, auth=token_auth)\n\nawait domo_role.add_user(user = domo_user)\n\n[DomoUser(id='1345408759', display_name='Alexis Lorenz (DataMaven)', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1102391116', display_name='Andrea Henderson', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1095515127', display_name='Andrew Chaffin', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='2074422502', display_name='Bard Higgins', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1865099622', display_name='Ben Schein', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='587894148', display_name='Bryan Van Kampen', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='307632801', display_name='Dan Brinton', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='68216396', display_name='Elliott Leonard', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1026818196', display_name='Giuseppe Russo', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='244750981', display_name='Gordon Pont', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='55874022', display_name='Grant Smith', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='805381129', display_name='Jack Wang', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1893952720', display_name='Jae Wilson1', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1141078945', display_name='Justin Pumford', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='475856860', display_name='Noah Finberg', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='617808774', display_name='Richard Carey', email_address=None, role_id=1, publisher_domain=None, subscriber_domain=None, virtual_user_id=None)]"
  },
  {
    "objectID": "classes/domorole.html#handle-role-metadata",
    "href": "classes/domorole.html#handle-role-metadata",
    "title": "Domo Role",
    "section": "Handle Role Metadata",
    "text": "Handle Role Metadata\n\nsource\n\nDomoRole.update_role_metadata\n\n DomoRole.update_role_metadata\n                                (auth:domolibrary.client.DomoAuth.DomoAuth\n                                =None, role_name=None,\n                                role_description:str=None,\n                                debug_api:bool=False,\n                                session:httpx.AsyncClient=None,\n                                return_raw:bool=False)\n\n\nsample implementation of update_role_metadata\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\n# retrieve the super_admin role\nrole_res = await role_routes.get_roles(auth=token_auth)\ndomo_role = next((DomoRole._from_json(role, auth=token_auth)\n                 for role in role_res.response if role.get('name') == 'super_admin'), None)\n\nawait domo_role.update_role_metadata(role_description=f'updated via domolibrary on {dt.date.today()}', debug_api=False)\n\nDomoRole(id=810756122, name='super_admin', description='updated via domolibrary on 2023-03-17', is_system_role=0, grant_ls=[], membership_ls=[])"
  },
  {
    "objectID": "classes/domorole.html#handle-crud-role",
    "href": "classes/domorole.html#handle-crud-role",
    "title": "Domo Role",
    "section": "handle CRUD Role",
    "text": "handle CRUD Role\n\nsource\n\nDomoRole.delete_role\n\n DomoRole.delete_role (role_id:int,\n                       auth:domolibrary.client.DomoAuth.DomoAuth=None,\n                       debug_api:bool=False,\n                       session:httpx.AsyncClient=None)\n\n\nsource\n\n\nDeleteRole_Error\n\n DeleteRole_Error (role_id, domo_instance)\n\nbase exception\n\nsample implementation of delete_role\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntry:\n    await DomoRole.delete_role(role_id = 1019636738 , auth = token_auth)\nexcept Exception as e:\n    print(e)\n\nrole: 1019636738 not found at domo-dojo"
  },
  {
    "objectID": "classes/domorole.html#search-and-get-roles",
    "href": "classes/domorole.html#search-and-get-roles",
    "title": "Domo Role",
    "section": "Search and Get Roles",
    "text": "Search and Get Roles\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nawait DomoRoles.get_roles(auth=token_auth)\n\n[DomoRole(id=1, name='Admin', description='Full access to everything', is_system_role=1, grant_ls=[], membership_ls=[]),\n DomoRole(id=2, name='Privileged', description='Full access except for editing users and settings owners', is_system_role=1, grant_ls=[], membership_ls=[]),\n DomoRole(id=3, name='Editor', description='Can edit Cards, Pages, DataSets, and Dataflows', is_system_role=1, grant_ls=[], membership_ls=[]),\n DomoRole(id=4, name='Participant', description='Read only access on Cards, Pages DataSets and Dataflows', is_system_role=1, grant_ls=[], membership_ls=[]),\n DomoRole(id=5, name='Social', description='Access limited to social features', is_system_role=1, grant_ls=[], membership_ls=[]),\n DomoRole(id=104295428, name='super_admin_v3', description='upsert via DomoLibrary', is_system_role=0, grant_ls=[], membership_ls=[]),\n DomoRole(id=275763436, name='Super_Admin', description='Full access to everything', is_system_role=0, grant_ls=[], membership_ls=[]),\n DomoRole(id=810756122, name='super_admin', description='updated via domolibrary on 2023-03-17', is_system_role=0, grant_ls=[], membership_ls=[]),\n DomoRole(id=1563101750, name='dl_department_admin', description='deployed via domo_library script - updated 2023-03-17', is_system_role=0, grant_ls=[], membership_ls=[]),\n DomoRole(id=1662852841, name='dl_test', description='deployed via domo_library script - updated 2023-03-17', is_system_role=0, grant_ls=[], membership_ls=[]),\n DomoRole(id=1927158482, name='Domo_Admins', description='Full access to everything', is_system_role=0, grant_ls=[], membership_ls=[]),\n DomoRole(id=2097317660, name='Dojo_Default_Priviliged', description='Full access except for editing users and settings owners', is_system_role=0, grant_ls=[], membership_ls=[])]\n\n\n\nsource\n\nDomoRoles.search_role\n\n DomoRoles.search_role (role_name:str,\n                        auth:domolibrary.client.DomoAuth.DomoAuth,\n                        debug_api:bool=False,\n                        session:httpx.AsyncClient=None,\n                        return_raw:bool=False)\n\n\nsource\n\n\nSearchRole_NotFound\n\n SearchRole_NotFound (domo_instance, role_id, message='not found',\n                      function_name='search_role')\n\nbase exception\n\nsample implementation of searhc_role\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nawait DomoRoles.search_role(auth=token_auth, role_name = 'Admin')\n\nDomoRole(id=1, name='Admin', description='Full access to everything', is_system_role=1, grant_ls=[], membership_ls=[])"
  },
  {
    "objectID": "classes/domorole.html#handle-crud-roles",
    "href": "classes/domorole.html#handle-crud-roles",
    "title": "Domo Role",
    "section": "Handle CRUD Roles",
    "text": "Handle CRUD Roles\n\nsource\n\nCreateRole_Error\n\n CreateRole_Error (domo_instance, role_id, message, status,\n                   function_name='create_role')\n\nbase exception\n\nsource\n\n\nDomoRoles.create_role\n\n DomoRoles.create_role (auth:domolibrary.client.DomoAuth.DomoAuth,\n                        name:str, description:str=None,\n                        debug_api:bool=False,\n                        session:httpx.AsyncClient=None)\n\n\nsample implementation of create_role\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntry:\n    await DomoRoles.create_role(auth = token_auth, name = 'super_admin', description = 'created via DomoLibrary',)\nexcept Exception as e:\n    print(e)\n\ncreate_role: super_admin :Status 400 - role already exists at domo-dojo\n\n\n\nsource\n\n\n\nDomoRoles.upsert_role\n\n DomoRoles.upsert_role (auth:domolibrary.client.DomoAuth.DomoAuth,\n                        name:str, description:str=None, grant_ls:[<class'd\n                        omolibrary.classes.DomoGrant.DomoGrant'>]=None,\n                        debug_api:bool=False, debug_prn:bool=False,\n                        session:httpx.AsyncClient=None)\n\n\nsample implementation of upsert_role\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ngrant_ls = ['cloud.admin',\n            'versions.repository.admin',\n            'codeengine.package.manage',\n            'appstore.admin',\n            'datastore.admin',\n            'certifiedcontent.admin']\n\nawait DomoRoles.upsert_role(auth=token_auth, name='super_admin_v3', description='upsert via DomoLibrary',grant_ls= grant_ls)\n\nDomoRole(id=104295428, name='super_admin_v3', description='upsert via DomoLibrary', is_system_role=0, grant_ls=[DomoGrant(id='cloud.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='versions.repository.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='codeengine.package.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='appstore.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='datastore.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='certifiedcontent.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None)], membership_ls=[])\n\n\n\n# #| export\n\n\n# async def set_as_default_role(self, debug_api: bool = False):\n#     return await role_routes.set_default_role(auth=self.auth,\n#                                                 role_id=self.id,\n#                                                 debug_api=debug_api)"
  },
  {
    "objectID": "classes/domouser.html",
    "href": "classes/domouser.html",
    "title": "User",
    "section": "",
    "text": "source\n\n\n\n DomoUser (id:str, display_name:str=None, email_address:str=None,\n           role_id:str=None, publisher_domain:str=None,\n           subscriber_domain:str=None, virtual_user_id:str=None,\n           auth:Optional[domolibrary.client.DomoAuth.DomoAuth]=None)\n\na class for interacting with a Domo User\n\nimport os\nimport domolibrary.routes.bootstrap as bootstrap_routes\n\nauth = dmda.DomoFullAuth(\n    domo_instance=\"domo-dojo\",\n    domo_password=os.environ[\"DOJO_PASSWORD\"],\n    domo_username=\"jae@onyxreporting.com\",\n)\n\nres = await bootstrap_routes.get_bootstrap_pages(auth=auth)\n\npage_obj = res.response[10]\nowners_ls = page_obj.get(\"owners\")\n\nDomoUser._from_bootstrap_json(auth=auth, user_obj=owners_ls[0])\n\nDomoUser(id='1345408759', display_name='Alexis Lorenz (DataMaven)', email_address=None, role_id=None, publisher_domain=None, subscriber_domain=None, virtual_user_id=None)\n\n\n\nsource\n\n\n\n\n DomoUser.reset_password (new_password:str, debug_api:bool=False)\n\nreset your password, will respect password restrictions set up in the Domo UI\n\nsource\n\n\n\n\n DomoUser.request_password_reset (domo_instance:str, email:str,\n                                  locale:str='en-us',\n                                  debug_api:bool=False,\n                                  session:httpx.AsyncClient=None)\n\nrequest password reset email. Note: does not require authentication.\n\n@patch_to(DomoUser)\nasync def set_user_landing_page(\n    self: DomoUser,\n    page_id: str,\n    user_id: str = None,\n    auth: dmda.DomoAuth = None,\n    debug_api: bool = False,\n):\n\n    res = await user_routes.set_user_landing_page(\n        auth=auth or self.auth,\n        page_id=page_id,\n        user_id=self.id or user_id,\n        debug_api=debug_api,\n    )\n\n    if res.status != 200:\n        return False\n\n    return True"
  },
  {
    "objectID": "classes/domouser.html#search-and-get-users",
    "href": "classes/domouser.html#search-and-get-users",
    "title": "User",
    "section": "Search and GET Users",
    "text": "Search and GET Users\n\nsource\n\nDomoUsers.all_users\n\n DomoUsers.all_users (auth:domolibrary.client.DomoAuth.DomoAuth,\n                      debug_api:bool=False, debug_prn:bool=False,\n                      debug_log:bool=False, logger:Optional[domolibrary.cl\n                      ient.Logger.Logger]=None)\n\nretrieves all users from Domo\n\nsample implementation of get all_users\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ndomo_users = await DomoUsers.all_users(\n    auth=token_auth, debug_api=False, debug_prn=False\n)\n\npd.DataFrame(domo_users[0:3])\n\n\n\n\n\n  \n    \n      \n      id\n      display_name\n      email_address\n      role_id\n      publisher_domain\n      subscriber_domain\n      virtual_user_id\n      auth\n    \n  \n  \n    \n      0\n      None\n      monitor\n      monitor@domo.com\n      1\n      None\n      None\n      None\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n    \n    \n      1\n      1006847540\n      Marc-Anton Clavel\n      marcanton.clavel@domo.com\n      2\n      None\n      None\n      None\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n    \n    \n      2\n      1012895591\n      JeMiller\n      JeMiller@marketaxess.com\n      2097317660\n      None\n      None\n      None\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n    \n  \n\n\n\n\n\nsource\n\n\n\nDomoUsers.by_id\n\n DomoUsers.by_id (user_ids:list[str],\n                  auth:domolibrary.client.DomoAuth.DomoAuth,\n                  only_allow_one:bool=True, debug_api:bool=False,\n                  return_raw:bool=False)\n\n\nsample implementation of searching users by_id\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\n\nawait DomoUsers.by_id(\n    auth=token_auth,\n    user_ids=[\"1006847540\", \"1012895591\"],\n    only_allow_one=False,\n    return_raw=False,\n)\n\n[DomoUser(id='1012895591', display_name='JeMiller', email_address='JeMiller@marketaxess.com', role_id=2097317660, publisher_domain=None, subscriber_domain=None, virtual_user_id=None),\n DomoUser(id='1006847540', display_name='Marc-Anton Clavel', email_address='marcanton.clavel@domo.com', role_id=2, publisher_domain=None, subscriber_domain=None, virtual_user_id=None)]\n\n\n\nsource\n\n\n\nDomoUsers.by_email\n\n DomoUsers.by_email (email_ls:list[str],\n                     auth:domolibrary.client.DomoAuth.DomoAuth,\n                     only_allow_one:bool=True, debug_api:bool=False,\n                     debug_prn:bool=False, return_raw:bool=False)\n\n\nsource\n\n\nDomoUsers.util_match_users_obj_to_emails\n\n DomoUsers.util_match_users_obj_to_emails (user_ls:list[dict],\n                                           user_email_ls:list[str])\n\npass in an array of user emails to match against an array of Domo User\n\nsource\n\n\nDomoUsers.util_match_domo_users_to_emails\n\n DomoUsers.util_match_domo_users_to_emails\n                                            (domo_users:list[__main__.Domo\n                                            User],\n                                            user_email_ls:list[str])\n\npass in an array of user emails to match against an array of Domo User\n\nsample implementation of searching for a user by email\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntry:\n    res = await DomoUsers.by_email(\n        auth=token_auth,\n        email_ls=[\"jae@onyxreporting.com\"],\n        only_allow_one=True,\n        return_raw=True,\n        debug_api=False,\n        debug_prn=False,\n    )\n\n    pprint(res)\n    \nexcept user_routes.SearchUser_NoResults as e:\n    print(e)\n\nResponseGetData(status=200, response={'id': 1893952720, 'displayName': 'Jae Wilson1', 'roleId': 1, 'userName': 'jae@onyxreporting.com', 'emailAddress': 'jae@onyxreporting.com'}, is_success=True)\n\n\n\nsource\n\n\n\nDomoUsers.virtual_user_by_subscriber_instance\n\n DomoUsers.virtual_user_by_subscriber_instance\n                                                (subscriber_instance_ls:st\n                                                r, auth:domolibrary.client\n                                                .DomoAuth.DomoAuth,\n                                                debug_api:bool=False,\n                                                return_raw:bool=False)\n\n\nsample implementation of retrieving virtual users for a subscriber instance\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\n\nres = await DomoUsers.virtual_user_by_subscriber_instance(\n    auth=token_auth,\n    subscriber_instance_ls=[\"domo-dojo\", \"test\"],\n    # return_raw=True,\n    debug_api=False,\n)\nprint(res)\n\nDomoUser(id='2bcabab7-128e-4f47-8219-c8548588d7fc', display_name=None, email_address=None, role_id=None, publisher_domain='domo-dojo.domo.com', subscriber_domain='domo-dojo.domo.com', virtual_user_id='fc:ce69e5f0-ab88-46df-94ab-32b5f6dfd4e7')"
  },
  {
    "objectID": "classes/domouser.html#crud-users",
    "href": "classes/domouser.html#crud-users",
    "title": "User",
    "section": "CRUD Users",
    "text": "CRUD Users\n\nsource\n\nDomoUsers.create_user\n\n DomoUsers.create_user (auth:domolibrary.client.DomoAuth.DomoAuth,\n                        display_name, email_address, role_id,\n                        password:str=None,\n                        send_password_reset_email:bool=False,\n                        debug_api:bool=False, session=<class\n                        'httpx.AsyncClient'>)\n\nclass method that creates a new Domo user\n\nsource\n\n\nCreateUser_MissingRole\n\n CreateUser_MissingRole (domo_instance, email_address)\n\nbase exception\n\nsource\n\n\nDomoUsers.upsert_user\n\n DomoUsers.upsert_user (auth:domolibrary.client.DomoAuth.DomoAuth,\n                        email_address:str, display_name:str=None,\n                        role_id:str=None, debug_api:bool=False,\n                        debug_prn:bool=False,\n                        session:httpx.AsyncClient=None)\n\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nawait DomoUsers.upsert_user(email_address='test4@test.com',\n                            display_name= f'test - updated via dl {dt.date.today()}',\n                            role_id = 3,\n                            auth=token_auth, debug_prn=True, debug_api = False)\n\nResponseGetData(status=200, response={'attributes': [{'key': 'id', 'values': [663516735]}, {'key': 'displayName', 'values': ['test - updated via dl 2023-03-17']}, {'key': 'userName', 'values': ['test4@test.com']}, {'key': 'emailAddress', 'values': ['test4@test.com']}, {'key': 'modified', 'values': [1679017419440]}, {'key': 'created', 'values': [1679007751000]}, {'key': 'roleId', 'values': [3]}, {'key': 'isAnonymous', 'values': [True]}, {'key': 'isSystemUser', 'values': [False]}, {'key': 'isPending', 'values': [True]}, {'key': 'isActive', 'values': [True]}, {'key': 'invitorUserId', 'values': [1893952720]}, {'key': 'avatarKey', 'values': ['/api/content/v1/avatar/USER/663516735']}], 'id': 663516735, 'displayName': 'test - updated via dl 2023-03-17', 'roleId': 3, 'userName': 'test4@test.com', 'emailAddress': 'test4@test.com'}, is_success=True)"
  },
  {
    "objectID": "classes/domodatacenter.html",
    "href": "classes/domodatacenter.html",
    "title": "domolibrary",
    "section": "",
    "text": "DomoDatacenter\n\na class based approach to searching the datacenter\n\n\nsource\n\nDomoEntity\n\n DomoEntity (value, names=None, module=None, qualname=None, type=None,\n             start=1)\n\nenumerates the entities that can be passed to the datacenter Search API\n\nsource\n\n\nDomoDatacenter\n\n DomoDatacenter (auth)\n\nclass for quering entities in the datacenter\n\nsource\n\n\nDomoDatacenter.generate_search_datacenter_body\n\n DomoDatacenter.generate_search_datacenter_body (entity_name:str=None,\n                                                 entity_ls:list[str]=list[\n                                                 __main__.DomoEntity], fil\n                                                 ter_ls:[<class'dict'>]=No\n                                                 ne, combineResults:bool=F\n                                                 alse, count:int=100,\n                                                 offset:int=0)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nentity_name\nstr\nNone\nentity to search for, uses fuzzy logic\n\n\nentity_ls\nlist\nlist\nlist of entity types to search\n\n\nfilter_ls\n[<class ‘dict’>]\nNone\nfilter parameters\n\n\ncombineResults\nbool\nFalse\nfacet / split results\n\n\ncount\nint\n100\n\n\n\noffset\nint\n0\n\n\n\n\n\nsample implementation of generate_search_datacenter_body\n\nDomoDatacenter.generate_search_datacenter_body(\n    entity_ls=[DomoEntity.ACCOUNT],\n    entity_name='test_rename'\n)\n\n{'query': '*test_rename*',\n 'entityList': [['account']],\n 'count': 100,\n 'offset': 0,\n 'filters': [],\n 'combineResults': False}\n\n\n\n\nExamples of valid search strings\nNotice that the account query body uses key entityList instead of entities.\nNot all instances of domo will allow you to search for accounts via the Datacenter’s query API, instead, consider using DomoAccounts to retrieve accounts filtered by name and AccountConfig type.\n\ns = {\n    \"entityList\": [[\"account\"]],\n    \"count\": 100, \"offset\": 0,\n    \"filters\": [\n        {\n            \"filterType\": \"term\",\n            \"field\": \"dataprovidername_facet\",\n            \"value\": \"Amazon Athena High Bandwidth\",\n            \"name\": \"Data Provider Type\",\n            \"not\": False,\n            \"label\": \"Amazon Athena High Bandwidth\",\n        }\n    ],\n    \"query\": \"**\",\n    \"combineResults\": False,\n    \"sort\": {\"fieldSorts\": [{\"field\": \"display_name_sort\", \"sortOrder\": \"ASC\"}]},\n}\n\ns = {\n    \"entities\": [\"DATASET\"],\n    \"count\": 30, \"offset\": 0,\n    \"filters\": [\n        {\n            \"filterType\": \"term\",\n            \"field\": \"dataprovidername_facet\", \"value\": \"DataFlow\", \"name\": \"DataFlow\", \"not\": False\n        }],\n    \"combineResults\": True,\n    \"query\": \"*\", \n    \"sort\": {\"isRelevance\": False, \"fieldSorts\": [{\"field\": \"last_updated\", \"sortOrder\": \"DESC\"}]}}\n\n\n#     @classmethod\n#     async def search_datasets(cls,\n#                               full_auth=dmda.DomoFullAuth,\n#                               body: dict = None,\n#                               session: httpx.AsyncClient = None,\n#                               maximum: int = None,\n#                               debug_api=False) -> list[DomoDataset]:\n\n#         if not body:\n#             body = DomoDatacenter.generate_search_datacenter_body(\n#                 entities_list=['DATASET'],\n#                 filters=[],\n#                 count=1000,\n#                 offset=0,\n#                 combineResults=False\n#             )\n\n#         if debug_api:\n#             print(body)\n\n#         json_list = await cls.search_datacenter(full_auth=full_auth,\n#                                                 maximum=maximum,\n#                                                 body=body,\n#                                                 session=session,\n#                                                 debug_api=False)\n\n#         if json_list:\n#             return await asyncio.gather(\n#                 *[DomoDataset.get_from_id(id=json_obj.get('databaseId'), full_auth=full_auth, debug_api=debug_api)\n#                   for json_obj in json_list]\n#             )\n\n#     @classmethod\n#     async def get_lineage_upstream(cls,\n#                                    full_auth: dmda.DomoFullAuth,\n#                                    entity_id,\n#                                    entity_type,\n#                                    session: httpx.AsyncClient = None,\n#                                    debug_api: bool = False,\n#                                    debug_prn: bool = False):\n\n#         import Library.DomoClasses.DomoDataflow as dmdf\n#         import Library.DomoClasses.DomoDataset as dmds\n\n#         try:\n#             if not session:\n#                 session = httpx.AsyncClient()\n#                 is_close_session = True\n\n#             res = await datacenter_routes.get_lineage_upstream(full_auth=full_auth,\n#                                                                entity_type=entity_type,\n#                                                                entity_id=entity_id,\n#                                                                session=session, debug_api=debug_api)\n\n#             if res.status == 200:\n#                 obj = res.response\n\n#                 domo_obj = []\n#                 for key, item in obj.items():\n#                     if item.get('type') == 'DATA_SOURCE':\n#                         domo_obj.append(await dmds.DomoDataset.get_from_id(full_auth=full_auth, id=item.get('id')))\n\n#                     if item.get('type') == 'DATAFLOW':\n#                         # print(item.get('id'))\n#                         domo_obj.append(await dmdf.DomoDataflow.get_from_id(full_auth=full_auth, id=item.get('id')))\n#                         pass\n\n#                 return domo_obj\n#             else:\n#                 return None\n\n#         finally:\n#             if is_close_session:\n#                 await session.aclose()\n\n#     @classmethod\n#     async def get_accounts(cls, full_auth: dmda.DomoFullAuth,\n#                            search_str: str = None,\n#                            is_exact_match: bool = True,\n#                            maximum: int = None,\n#                            session: httpx.AsyncClient = None, debug_api: bool = False):\n\n#         import Library.DomoClasses.DomoAccount as dma\n\n#         json_ls = None\n\n#         if search_str:\n#             body = datacenter_routes.generate_search_datacenter_account_body(\n#                 search_str=search_str, is_exact_match=is_exact_match)\n\n#             search_ls = await cls.search_datacenter(full_auth=full_auth,\n#                                                     maximum=maximum,\n#                                                     body=body,\n#                                                     session=session,\n#                                                     debug_api=debug_api)\n\n#             if not search_ls or len(search_ls) == 0:\n#                 return None\n\n#             json_ls = [{'id': obj.get('databaseId')} for obj in search_ls]\n\n#         else:\n#             res = await account_routes.get_accounts(full_auth=full_auth, session=session, debug_api=debug_api)\n\n#             if debug_api:\n#                 print(res)\n\n#             if res.status != 200:\n#                 return None\n\n#             json_ls = res.response\n\n#         domo_account_ls = await asyncio.gather(*[dma.DomoAccount.get_from_id(account_id=obj.get('id'), full_auth=full_auth) for obj in json_ls])\n\n#         if is_exact_match and search_str:\n#             return next((domo_account for domo_account in domo_account_ls if domo_account.name == search_str), None)\n\n#         return domo_account_ls"
  },
  {
    "objectID": "classes/domopublish.html",
    "href": "classes/domopublish.html",
    "title": "Domo Publish",
    "section": "",
    "text": "Publish\n\nsource\n\nDomoPublication_Subscription\n\n DomoPublication_Subscription (subscription_id:str, publication_id:str,\n                               domain:str, created_dt:Optional[datetime.da\n                               tetime]=None)\n\n\nsource\n\n\nDomoPublication_Content\n\n DomoPublication_Content (content_id:str, entity_type:str, entity_id:str,\n                          entity_domain:str, is_v2:bool,\n                          is_direct_content:bool)\n\n\nsource\n\n\nDomoPublication_UnexpectedContentType\n\n DomoPublication_UnexpectedContentType (publication_id, content_type,\n                                        domo_instance)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nDomoPublication\n\n DomoPublication (id:str, name:str, description:str, is_v2:bool,\n                  created_dt:datetime.datetime,\n                  auth:domolibrary.client.DomoAuth.DomoAuth=None, subscrip\n                  tion_authorizations:[<class'__main__.DomoPublication_Sub\n                  scription'>]=<factory>, content:[<class'__main__.DomoPub\n                  lication_Content'>]=<factory>,\n                  content_page_id_ls:[<class'str'>]=<factory>,\n                  content_dataset_id_ls:[<class'str'>]=<factory>)\n\n\nsource\n\n\nDomoPublication.get_from_id\n\n DomoPublication.get_from_id (publication_id=None,\n                              auth:domolibrary.client.DomoAuth.DomoAuth=No\n                              ne)\n\n\nsample implementation of get_from_id\n\nimport os\nimport pandas as pd\n\npublication_id = \"431005fd-ec85-41fe-88f6-7b888222aec2\"\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ndomo_publication = await DomoPublication.get_from_id(\n    publication_id=publication_id, auth=token_auth\n)\nfrom pprint import pprint\n\npprint(domo_publication)\n\nDomoPublication(id='431005fd-ec85-41fe-88f6-7b888222aec2', name='Variables Example from Domo-Dojo', description='', is_v2=True, created_dt=datetime.datetime(2022, 10, 13, 15, 14, 51, 178000), subscription_authorizations=[DomoPublication_Subscription(subscription_id='e1296172-c731-49d3-b543-b5c098cf5f8d', publication_id='431005fd-ec85-41fe-88f6-7b888222aec2', domain='modocorp-admin.domo.com', created_dt=datetime.datetime(2022, 10, 13, 15, 14, 51, 178000))], content=[DomoPublication_Content(content_id='ec909f98-b95b-4b04-b328-f21da172822f', entity_type='PAGE', entity_id='1880852133', entity_domain='domo-dojo.domo.com', is_v2=True, is_direct_content=True), DomoPublication_Content(content_id='460edf09-cca0-4a4c-bba0-51f82a1a5e84', entity_type='DATASET', entity_id='8848cdf1-28d4-46e9-93e4-7afb4b5ec1d2', entity_domain='domo-dojo.domo.com', is_v2=True, is_direct_content=True), DomoPublication_Content(content_id='aba70e14-ecf2-4c20-98af-8ffb4d56d183', entity_type='DATASET', entity_id='cf149711-df55-4dc3-a159-59a26d066baa', entity_domain='domo-dojo.domo.com', is_v2=True, is_direct_content=True), DomoPublication_Content(content_id='b70b4e6f-c4a9-444b-886a-774fa5405472', entity_type='DATASET', entity_id='ee24d234-303e-46aa-b062-9905dc0d8622', entity_domain='domo-dojo.domo.com', is_v2=True, is_direct_content=True), DomoPublication_Content(content_id='b9683bc2-33cc-4b10-8b31-9e394da85655', entity_type='DATASET', entity_id='ea859b06-5dbe-4c31-be76-de921447d550', entity_domain='domo-dojo.domo.com', is_v2=True, is_direct_content=True)], content_page_id_ls=['1880852133'], content_dataset_id_ls=['8848cdf1-28d4-46e9-93e4-7afb4b5ec1d2', 'cf149711-df55-4dc3-a159-59a26d066baa', 'ee24d234-303e-46aa-b062-9905dc0d8622', 'ea859b06-5dbe-4c31-be76-de921447d550'])\n\n\n\n\n\n\nSubscription\n\n\nDomoPublications\n\nsource\n\nDomoPublications\n\n DomoPublications ()\n\n\nsample implementation of get_subscription_summaries\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nawait DomoPublications.get_subscription_summaries(auth = token_auth, return_raw= False)\n\n[{'subscriptionId': 'a825f210-77cf-4313-a73d-4d2ae7cd3397',\n  'publicationId': 'c7119a3e-f97d-4221-83c6-56ddd38073b0',\n  'publisherDomain': 'datamavenllc-io.domo.com',\n  'publicationSummary': {'id': 'c7119a3e-f97d-4221-83c6-56ddd38073b0',\n   'name': 'New Feature Releases',\n   'description': 'Domo Announcements',\n   'dataSets': 4,\n   'pages': 2,\n   'cards': 42,\n   'totalSubscribers': 0,\n   'invalidSubscribers': 0,\n   'invalidDatasetSubscribers': 0,\n   'invalidPageSubscribers': 0,\n   'invalidCardSubscribers': 0,\n   'isV2': True,\n   'hasDuplicate': False,\n   'refreshing': False},\n  'status': 'READY',\n  'result': 'SUCCESS',\n  'description': 'Success.',\n  'datasets': 4,\n  'pages': 2,\n  'cards': 42,\n  'created': 1674166687000,\n  'updated': 1674166687000},\n {'subscriptionId': '3436f012-d9ff-4903-835e-3b88dcce11c9',\n  'publicationId': 'd81b0a9a-e6f6-4ca0-b170-c57f91e75c22',\n  'publisherDomain': 'datamavenllc-io.domo.com',\n  'publicationSummary': {'id': 'd81b0a9a-e6f6-4ca0-b170-c57f91e75c22',\n   'name': 'Test #2 - Domo Publish',\n   'description': '',\n   'dataSets': 8,\n   'pages': 4,\n   'cards': 46,\n   'totalSubscribers': 0,\n   'invalidSubscribers': 0,\n   'invalidDatasetSubscribers': 0,\n   'invalidPageSubscribers': 0,\n   'invalidCardSubscribers': 0,\n   'isV2': True,\n   'hasDuplicate': False,\n   'refreshing': False},\n  'status': 'READY',\n  'result': 'MISSING_PAGE',\n  'description': 'Missing page for content id, 465577116. Missing card for content id, 2139036748. Missing card for content id, 878688887. Missing additional content...',\n  'datasets': 8,\n  'pages': 3,\n  'cards': 42,\n  'created': 1645671430000,\n  'updated': 1674168501000}]\n\n\n\nsource\n\n\n\nDomoPublications.search_publications\n\n DomoPublications.search_publications (auth=<class\n                                       'domolibrary.client.DomoAuth.DomoAu\n                                       th'>, search_term:str=None,\n                                       session:httpx.AsyncClient=None,\n                                       debug_api:bool=False,\n                                       return_raw:bool=False)\n\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=os.environ['BETA_INSTANCE'], domo_access_token=os.environ[\"BETA_ACCESS_TOKEN\"]\n)\n\nawait DomoPublications.search_publications(auth = token_auth, return_raw=False)\n\n[DomoPublication(id='a1a192c0-75f5-4d1a-bb2b-ff0e6bf67c68', name='Data Lineage to playstation-dso-adobe', description='', is_v2=True, created_dt=None, subscription_authorizations=[], content=[], content_page_id_ls=[], content_dataset_id_ls=[]),\n DomoPublication(id='45288d9c-d626-417e-90aa-b43048a6d5b8', name='Monit instance dataset to d2c', description='', is_v2=True, created_dt=None, subscription_authorizations=[], content=[], content_page_id_ls=[], content_dataset_id_ls=[]),\n DomoPublication(id='dffbe7b3-6c78-4961-9b30-16d03d53c7bc', name='MONIT_Instance_dataset_to ORT', description='', is_v2=True, created_dt=None, subscription_authorizations=[], content=[], content_page_id_ls=[], content_dataset_id_ls=[]),\n DomoPublication(id='c2dda1f7-16d2-4b3d-8f9c-19ea198daa58', name='Monitoring lineage to D2C', description='', is_v2=True, created_dt=None, subscription_authorizations=[], content=[], content_page_id_ls=[], content_dataset_id_ls=[]),\n DomoPublication(id='570f7ee8-825a-4f06-8de5-36d18d688aa7', name='Page_Card_Dataset_instance to D2C', description='', is_v2=True, created_dt=None, subscription_authorizations=[], content=[], content_page_id_ls=[], content_dataset_id_ls=[]),\n DomoPublication(id='87198066-68aa-4f2e-9185-d63b11ac895a', name='Publish Monitoring to DSO Tokyo ', description='', is_v2=True, created_dt=None, subscription_authorizations=[], content=[], content_page_id_ls=[], content_dataset_id_ls=[]),\n DomoPublication(id='a9446860-a01c-4451-a042-478e6f66ab91', name='Remote Domostats Audit to D2C', description='', is_v2=True, created_dt=None, subscription_authorizations=[], content=[], content_page_id_ls=[], content_dataset_id_ls=[]),\n DomoPublication(id='4cb9d713-5457-47cf-80ee-121caf7ad13a', name='Remote Domostats People to D2C', description='', is_v2=True, created_dt=None, subscription_authorizations=[], content=[], content_page_id_ls=[], content_dataset_id_ls=[]),\n DomoPublication(id='76e105e9-cd3b-4b52-a5f6-9c76a5e5a717', name='TM Test Publication', description='', is_v2=True, created_dt=None, subscription_authorizations=[], content=[], content_page_id_ls=[], content_dataset_id_ls=[]),\n DomoPublication(id='984d6db8-1b87-4e55-9d5f-652b7bc99617', name='TST_Oleksii', description='', is_v2=True, created_dt=None, subscription_authorizations=[], content=[], content_page_id_ls=[], content_dataset_id_ls=[])]\n\n\n\n#    def convert_content_to_dataframe(self, return_raw: bool = False):\n\n#         output_ls = [{'plubication_id': self.id,\n#                       'publication_name': self.name,\n#                       'is_v2': self.is_v2,\n#                       'publish_created_dt': self.created_dt,\n#                       'entity_type': row.type,\n#                       'entity_id': row.id\n#                       } for row in self.content_entity_ls]\n\n#         if return_raw:\n#             return output_ls\n\n#         return pd.DataFrame(output_ls)\n\n#     def convert_lineage_to_dataframe(self, return_raw: bool = False):\n#         import pandas as pd\n#         import re\n\n#         flat_lineage_ls = self.lineage._flatten_lineage()\n\n#         output_ls = [{'plubication_id': self.id,\n#                       'publication_name': self.name,\n#                       'is_v2': self.is_v2,\n#                       'publish_created_dt': self.created_dt,\n#                       'entity_type': row.get('entity_type'),\n#                       'entity_id': row.get('entity_id')\n#                       } for row in flat_lineage_ls]\n\n#         if return_raw:\n#             return output_ls\n\n#         return pd.DataFrame(output_ls)\n\n#     @classmethod\n#     async def create_publication(cls,\n#                                  name: str,\n#                                  content_ls: [DomoPublication_Content],\n#                                  subscription_ls: [DomoPublication_Subscription],\n#                                  unique_id: str = None,\n#                                  description: str = None,\n#                                  auth: dmda.DomoAuth = None,\n#                                  debug: bool = False):\n\n#         if not isinstance(subscription_ls, list):\n#             subscription_ls = [subscription_ls]\n\n#         auth = auth or cls.auth\n#         domain_ls = []\n#         content_json_ls = []\n#         for sub in subscription_ls:\n#             domain_ls.append(sub.domain)\n#         for content_item in content_ls:\n#             content_json_ls.append(content_item.to_json())\n\n#         if not unique_id:\n#             unique_id = str(uuid.uuid4())\n#         if not description:\n#             description = ''\n\n#         body = publish_routes.generate_publish_body(url=f'{auth.domo_instance}.domo.com',\n#                                                     sub_domain_ls=domain_ls,\n#                                                     content_ls=content_json_ls,\n#                                                     name=name,\n#                                                     unique_id=unique_id,\n#                                                     description=description,\n#                                                     is_new=True)\n\n#         res = await publish_routes.create_publish_job(auth=auth, body=body)\n#         if debug:\n#             print('Create the new Publish job')\n#         if res.status != 200:\n#             print(res)\n#             await asyncio.sleep(2)\n#             res = await publish_routes.get_publication_by_id(auth=auth, publication_id=unique_id)\n#             if res.status != 200:\n#                 return None\n#             else:\n#                 return cls._from_json(obj=res.response, auth=auth)\n\n#         return cls._from_json(obj=res.response, auth=auth)\n\n#     @classmethod\n#     async def update_publication(cls,\n#                                  name: str,\n#                                  content_ls: [DomoPublication_Content],\n#                                  subscription_ls: [DomoPublication_Subscription],\n#                                  publication_id: str,\n#                                  description: str = None,\n#                                  auth: dmda.DomoAuth = None,\n#                                  debug: bool = False):\n\n#         if not isinstance(subscription_ls, list):\n#             subscription_ls = [subscription_ls]\n\n#         auth = auth or cls.auth\n#         domain_ls = []\n#         content_json_ls = []\n#         for sub in subscription_ls:\n#             domain_ls.append(sub.domain)\n#         for content_item in content_ls:\n#             content_json_ls.append(content_item.to_json())\n\n#         if not description:\n#             description = ''\n#         body = publish_routes.generate_publish_body(url=f'{auth.domo_instance}.domo.com',\n#                                                     sub_domain_ls=domain_ls,\n#                                                     content_ls=content_json_ls,\n#                                                     name=name,\n#                                                     unique_id=publication_id,\n#                                                     description=description,\n#                                                     is_new=False)\n\n#         res = await publish_routes.udpate_publish_job(auth= auth,\n#                                                       publication_id=publication_id,\n#                                                       body=body)\n#         if debug:\n#             print('Update Publish job by id')\n#         if res.status != 200:\n#             print(res)\n#             await asyncio.sleep(2)\n#             res = await publish_routes.get_publication_by_id(auth=auth, publication_id=publication_id)\n#             if res.status != 200:\n#                 return None\n#             else:\n#                 return cls._from_json(obj=res.response, auth=auth)\n\n#         return cls._from_json(obj=res.response, auth=auth)\n\n#     @classmethod\n#     async def get_subscription_invites_list(cls, auth: dmda.DomoAuth,\n#                                             debug: bool = False):\n\n#         res = await publish_routes.get_subscription_invites_list(auth=auth,\n#                                                                  debug=debug)\n#         if debug:\n#             print('Getting Publish subscription invites')\n\n#         if res.status == 200:\n#             return res.response\n\n#     @classmethod\n#     async def accept_invite_by_id(cls,\n#                                   auth: dmda.DomoAuth,\n#                                   subscription_id: str,\n#                                   debug: bool = False):\n\n#         res = await publish_routes.accept_invite_by_id(auth=auth,\n#                                                        subscription_id=subscription_id,\n#                                                        debug=debug)\n#         if debug:\n#             print(f'Accept invite by id {subscription_id}')\n\n#         if res.status == 200:\n#             return res.response"
  },
  {
    "objectID": "classes/domogrant.html",
    "href": "classes/domogrant.html",
    "title": "DomoGrant",
    "section": "",
    "text": "source\n\nDomoGrant\n\n DomoGrant (id:str, display_group:str=None, title:str=None,\n            depends_on_ls:list[str]=None, description:str=None,\n            role_membership_ls:list[str]=None)\n\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\nres = await grant_routes.get_grants(auth=token_auth)\n\n[ DomoGrant._from_json(row) for index, row in enumerate(res.response[0:5])]\n\n[DomoGrant(id='authorization.roles', display_group='COMPANY', title='Manage all roles', depends_on_ls=['ui.admin'], description='Create, edit and delete custom roles. Assign anyone to any role in this instance.', role_membership_ls=['1', '275763436', '810756122']),\n DomoGrant(id='audit', display_group='COMPANY', title='View activity logs', depends_on_ls=['ui.admin'], description='View and export audit logs.', role_membership_ls=['1', '275763436', '810756122', '1927158482', '1563101750', '2097317660']),\n DomoGrant(id='customer.edit', display_group='COMPANY', title='Manage all company settings', depends_on_ls=['ui.admin'], description='Manage company metadata, authentication rules, authorized domain rules, export security, mobile home screen layouts, publishing, SSO Configuration, whitelist rules, report scheduler and licenses.', role_membership_ls=['1', '275763436', '810756122']),\n DomoGrant(id='developer.token.manage', display_group='COMPANY', title='Manage all access tokens and API clients', depends_on_ls=['ui.admin'], description='Create and delete any access tokens and API clients.', role_membership_ls=['1', '275763436', '810756122', '1927158482']),\n DomoGrant(id='domo.system.messages', display_group='COMPANY', title='Receive Domo System Messages', depends_on_ls=['ui.admin'], description='Receive Domo system messages about maintenance and feature updates. Ensure at least one Admin receives these messages.', role_membership_ls=['1', '275763436', '810756122', '1927158482'])]"
  },
  {
    "objectID": "classes/domoinstanceconfig.html",
    "href": "classes/domoinstanceconfig.html",
    "title": "domolibrary",
    "section": "",
    "text": "a class based approach to configuring your domo instance\n\n\nsource\n\n\n\n DomoInstanceConfig (auth:domolibrary.client.DomoAuth.DomoAuth,\n                     allowlist:list[str]=<factory>)\n\nutility class that absorbs many of the domo instance configuration methods\n\nsource\n\n\n\n\n DomoInstanceConfig.get_allowlist\n                                   (auth:domolibrary.client.DomoAuth.DomoF\n                                   ullAuth=None,\n                                   session:httpx.AsyncClient=None,\n                                   return_raw:bool=False,\n                                   debug_api:bool=False)\n\nretrieves the allowlist for an instance\n\n\n\nimport os\n\n## this route requires full auth\n# auth = dmda.DomoTokenAuth(domo_instance = 'domo-dojo', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\nauth = dmda.DomoFullAuth(domo_instance= 'domo-dojo', domo_username= 'jae@onyxreporting.com', domo_password= os.environ['DOJO_PASSWORD'])\n\ndmicnfg = DomoInstanceConfig(auth = auth)\n\nawait dmicnfg.get_allowlist(auth=auth)\n\n['0.0.0.0/0', '20.25.167.71']\n\n\n\n\n\n\n\nThe updating the allowlist will automatically include the IP Address that submits the set_allowlist request. This prevents users from accidentally locking themselves out of domo.\nthe set_allowlist API always does a SET command, by default there is no UPDATE or INSERT option. This class-based implementation uses a combination of get_allowlist, MERGE and set_allowlist to perform an UPSERT equivalent.\n\n\nsource\n\n\n\n DomoInstanceConfig.upsert_allowlist (ip_address_ls:list[str],\n                                      debug_api:bool=False,\n                                      session:httpx.AsyncClient=None, auth\n                                      :domolibrary.client.DomoAuth.DomoAut\n                                      h=None)\n\n\nsource\n\n\n\n\n DomoInstanceConfig.set_allowlist (ip_address_ls:list[str],\n                                   debug_api:bool=False, auth:domolibrary.\n                                   client.DomoAuth.DomoFullAuth=None,\n                                   session:httpx.AsyncClient=None)\n\n\n\n\nimport os\n\n# this route requires full auth\n# auth = dmda.DomoTokenAuth(domo_instance = 'domo-dojo', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\nauth = dmda.DomoFullAuth(domo_instance='domo-dojo',\n                         domo_username='jae@onyxreporting.com', domo_password=os.environ['DOJO_PASSWORD'])\n\ndmicnfg = DomoInstanceConfig(auth = auth)\n\nawait dmicnfg.set_allowlist(auth=auth, ip_address_ls=['0.0.0.0/0'])\n\n['0.0.0.0/0', '40.77.45.151']\n\n\n\nimport os\n\n# this route requires full auth\n# auth = dmda.DomoTokenAuth(domo_instance = 'domo-dojo', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\nauth = dmda.DomoFullAuth(domo_instance='domo-dojo',\n                         domo_username='jae@onyxreporting.com', domo_password=os.environ['DOJO_PASSWORD'])\n\ndmicnfg = DomoInstanceConfig(auth = auth)\n\nawait dmicnfg.upsert_allowlist(auth=auth, ip_address_ls=['192.168.0.1'])\n\n['0.0.0.0/0', '192.168.0.1', '40.77.45.151']\n\n\n\nsource\n\n\n\n\n\n DomoInstanceConfig.get_grants\n                                (auth:domolibrary.client.DomoAuth.DomoAuth\n                                =None, debug_prn:bool=False,\n                                debug_api:bool=False,\n                                session:httpx.AsyncClient=None,\n                                return_raw:bool=False)\n\n\nimport os\nimport pandas as pd \n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\ndmicnfg = DomoInstanceConfig(auth = auth)\n\nres = await dmicnfg.get_grants(debug_prn= True)\n\npd.DataFrame(res[0:5])\n\nℹ️ - get_instance_grants: 84 grants returned from domo-dojo\n\n\n\n\n\n\n  \n    \n      \n      id\n      display_group\n      title\n      depends_on_ls\n      description\n      role_membership_ls\n    \n  \n  \n    \n      0\n      authorization.roles\n      COMPANY\n      Manage all roles\n      [ui.admin]\n      Create, edit and delete custom roles. Assign a...\n      [1, 275763436, 810756122]\n    \n    \n      1\n      audit\n      COMPANY\n      View activity logs\n      [ui.admin]\n      View and export audit logs.\n      [1, 275763436, 810756122, 1927158482, 15631017...\n    \n    \n      2\n      customer.edit\n      COMPANY\n      Manage all company settings\n      [ui.admin]\n      Manage company metadata, authentication rules,...\n      [1, 275763436, 810756122]\n    \n    \n      3\n      developer.token.manage\n      COMPANY\n      Manage all access tokens and API clients\n      [ui.admin]\n      Create and delete any access tokens and API cl...\n      [1, 275763436, 810756122, 1927158482]\n    \n    \n      4\n      domo.system.messages\n      COMPANY\n      Receive Domo System Messages\n      [ui.admin]\n      Receive Domo system messages about maintenance...\n      [1, 275763436, 810756122, 1927158482]\n    \n  \n\n\n\n\n\n\n\n\n\nsource\n\n\n\n DomoInstanceConfig.get_roles\n                               (auth:domolibrary.client.DomoAuth.DomoAuth=\n                               None, debug_api:bool=False,\n                               return_raw:bool=False,\n                               session:httpx.AsyncClient=None)\n\n\n\n\nimport domolibrary.client.DomoAuth as dmda\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(domo_instance = 'domo-dojo', domo_access_token= os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\ndmdic = DomoInstanceConfig(auth = token_auth)\n\nres = await dmdic.get_roles( return_raw = False)\n\npd.DataFrame(res)\n\n\n\n\n\n  \n    \n      \n      auth\n      id\n      name\n      description\n      is_system_role\n      grant_ls\n      membership_ls\n    \n  \n  \n    \n      0\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      1\n      Admin\n      Full access to everything\n      1\n      []\n      []\n    \n    \n      1\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      2\n      Privileged\n      Full access except for editing users and setti...\n      1\n      []\n      []\n    \n    \n      2\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      3\n      Editor\n      Can edit Cards, Pages, DataSets, and Dataflows\n      1\n      []\n      []\n    \n    \n      3\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      4\n      Participant\n      Read only access on Cards, Pages DataSets and ...\n      1\n      []\n      []\n    \n    \n      4\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      5\n      Social\n      Access limited to social features\n      1\n      []\n      []\n    \n    \n      5\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      104295428\n      super_admin_v3\n      upsert via DomoLibrary\n      0\n      []\n      []\n    \n    \n      6\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      275763436\n      Super_Admin\n      Full access to everything\n      0\n      []\n      []\n    \n    \n      7\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      810756122\n      super_admin\n      updated via domolibrary on 2023-03-17\n      0\n      []\n      []\n    \n    \n      8\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      1563101750\n      dl_department_admin\n      deployed via domo_library script - updated 202...\n      0\n      []\n      []\n    \n    \n      9\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      1662852841\n      dl_test\n      deployed via domo_library script - updated 202...\n      0\n      []\n      []\n    \n    \n      10\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      1927158482\n      Domo_Admins\n      Full access to everything\n      0\n      []\n      []\n    \n    \n      11\n      {'domo_instance': 'domo-dojo', 'domo_access_to...\n      2097317660\n      Dojo_Default_Priviliged\n      Full access except for editing users and setti...\n      0\n      []\n      []\n    \n  \n\n\n\n\n\n# #| export\n# @dataclass\n# class DomoConnector:\n#     id: str\n#     label: str\n#     title: str\n#     sub_title: str\n#     description: str\n#     create_date: dt.datetime\n#     last_modified: dt.datetime\n#     publisher_name: str\n#     writeback_enabled: bool\n#     tags: list[str] = field(default_factory=list)\n#     capabilities: list[str] = field(default_factory=list)\n\n#     @classmethod\n#     def _from_str(cls, obj):\n#         dd = DictDot(obj)\n\n#         return cls(\n#             id=dd.databaseId,\n#             label=dd.label,\n#             title=dd.title,\n#             sub_title=dd.subTitle,\n#             description=dd.description,\n#             create_date=cd.convert_epoch_millisecond_to_datetime(\n#                 dd.createDate),\n#             last_modified=cd.convert_epoch_millisecond_to_datetime(\n#                 dd.lastModified),\n#             publisher_name=dd.publisherName,\n#             writeback_enabled=dd.writebackEnabled,\n#             tags=dd.tags,\n#             capabilities=dd.capabilities\n#         )\n\n\n# @classmethod\n    # def _authorized_domain_from_string(cls, authorized_domain_string):\n    #     if authorized_domain_string == \"\":\n    #         return []\n\n    #     # return json.loads(authorized_domain_string)\n\n    #     return authorized_domain_string.split(',')\n\n    \n\n\n    \n\n    # @classmethod\n    # async def get_authorized_domains(cls, auth: DomoAuth, debug: bool = False, session: httpx.AsyncClient = None):\n    #     res = await instance_config_routes.get_authorized_domains(auth=auth,\n    #                                                               debug=debug,\n    #                                                               session=session)\n\n    #     if res.status == 200:\n    #         str = cls._authorized_domain_from_string(res.response.get('value'))\n    #         return str\n\n    # @classmethod\n    # async def get_connectors(cls, auth: DomoAuth,\n    #                          session: httpx.AsyncClient = None,\n    #                          debug: bool = False,\n    #                          limit=100,\n    #                          ):\n\n    #     is_close_session = False\n    #     if not session:\n    #         is_close_session = True\n    #         session = httpx.AsyncClient()\n\n    #     def arr_fn(res):\n    #         # pprint(res.response)\n    #         return res.response.get('searchObjects')\n\n    #     def alter_maximum_fn(res):\n    #         return res.response.get('totalResultCount')\n\n    #     body = {\n    #         \"count\": limit,\n    #         \"offset\": 0,\n    #         \"hideSearchObjects\": True,\n    #         \"combineResults\": False,\n    #         \"entities\": [\"CONNECTOR\"],\n    #         \"query\": \"*\"}\n\n    #     obj_list = await datacenter_routes.search_datacenter(\n    #         auth=auth,\n    #         arr_fn=arr_fn,\n    #         alter_maximum_fn=alter_maximum_fn,\n    #         body=body,\n    #         session=session,\n    #         limit=limit,\n    #         debug=debug)\n\n    #     if is_close_session:\n    #         await session.aclose()\n\n    #     return [DomoConnector._from_str(obj) for obj in obj_list]\n\n    # @classmethod\n    # async def update_authorized_domains(cls, auth: DomoAuth,\n    #                                     authorized_domain_list: list[str],\n    #                                     is_replace_existing_list: bool = False,\n    #                                     debug: bool = False):\n\n    #     if not is_replace_existing_list:\n    #         existing_domain_list = await cls.get_authorized_domains(auth=auth, debug=debug)\n\n    #         authorized_domain_list.extend(existing_domain_list)\n\n    #     if debug:\n    #         print(\n    #             f'🌡️ updating authorized domain with {\",\".join(authorized_domain_list)}')\n\n    #     res = await instance_config_routes.update_authorized_domains(auth=auth,\n    #                                                                  authorized_domain_list=authorized_domain_list,\n    #                                                                  debug=debug)\n\n    #     if debug:\n    #         \"update_authorized_domains\"\n    #         print(res)\n\n    #     if res.status == 200 or res.status == 204:\n    #         res = {'authorized_domains': await cls.get_authorized_domains(auth=auth, debug=debug),\n    #                'status': 200}\n\n    #     return res\n\n    # @classmethod\n    # async def get_applications(cls,\n    #                            auth: DomoAuth,\n    #                            debug: bool = False, session: httpx.AsyncClient = None, return_raw: bool = False):\n\n    #     res = await application_routes.get_applications(auth=auth,\n    #                                                     debug=debug,\n    #                                                     session=session)\n    #     if debug:\n    #         print('Getting Domostats jobs')\n\n    #     if res.status == 200 and not return_raw:\n    #         return [DomoApplication._from_json(job) for job in res.response]\n\n    #     if res.status == 200 and return_raw:\n    #         return res.response\n\n    # @classmethod\n    # async def get_publications(cls,\n    #                            auth: DomoAuth,\n    #                            debug: bool = False, session: httpx.AsyncClient = None, return_raw: bool = False):\n\n    #     res = await publish_routes.search_publications(auth=auth,\n    #                                                    debug=debug,\n    #                                                    session=session)\n    #     if debug:\n    #         print('Getting Publish jobs')\n\n    #     if res.status == 200 and not return_raw:\n    #         return await asyncio.gather(*[dmpb.DomoPublication.get_from_id(publication_id=job.get('id'),\n    #                                                                        auth=auth) for job in res.response])\n\n    #     if res.status == 200 and return_raw:\n    #         return res.response"
  },
  {
    "objectID": "classes/domoactivitylog.html",
    "href": "classes/domoactivitylog.html",
    "title": "Activity Log",
    "section": "",
    "text": "class ActivityLog_ObjectType(Enum):\n    \"\"\"enumerates valid object types to pass to activity log api\"\"\"\n\n    ACCESS_TOKEN = \"ACCESS_TOKEN\"\n    ACCOUNT = \"ACCOUNT\"\n    ACTIVITY_LOG = \"ACTIVITY_LOG\"\n    ALERT = \"ALERT\"\n    APP = \"APP\"\n    APPDB_COLLECTION = \"MAGNUM_COLLECTION\"\n    APPDB_DATASTORE = \"MAGNUM_DATASTORE\"\n    AUTHORITY = \"AUTHORITY\"\n    BEAST_MODE_FORMULA = \"BEAST_MODE_FORMULA\"\n    BUZZ_CHANNEL = \"CHANNEL\"\n    BUZZ_GROUP_CHAT = \"GROUP_CHAT\"\n    BUZZ_THREAD = \"HUDDLE\"\n    CARD = \"CARD\"\n    CHART_COLOR_PALETTE = \"CHART_COLOR_PALETTE\"\n    COLLECTION = \"COLLECTION\"\n    CUSTOMER = \"CUSTOMER\"\n    CUSTOMER_STATE = \"CUSTOMER_STATE\"\n    CUSTOMER_TIER = \"CUSTOMER_TIER\"\n    DATA_SCIENCE_NOTEBOOK = \"DATA_SCIENCE_NOTEBOOK\"\n    DATAFLOW = \"DATAFLOW_TYPE\"\n    DATASET = \"DATA_SOURCE\"\n    DATASOURCE = \"DATASOURCE\"\n    DEPLOYMENT = \"DEPLOYMENT\"\n    DRILL_VIEW = \"DRILL_VIEW\"\n    EASY_INVITE_LINK = \"EASY_INVITE_LINK\"\n    ENABLED = \"ENABLED\"\n    FILE = \"FILE\"\n    FILE_VERSION = \"FILE_REVISION\"\n    GROUP = \"GROUP\"\n    LICENSE_PAGE = \"LICENSE_PAGE\"\n    LOGIN_SETTINGS = \"LOGIN_SETTINGS\"\n    NAME = \"NAME\"\n    PDP_FILTER = \"ADC_FILTER\"\n    PDP_POLICY = \"ADC_POLICY\"\n    PAGE = \"PAGE\"\n    PAGE_ANALYZER = \"PAGE_ANALYZER\"\n    PAGE_COLLECTION = \"PAGE_COLLECTION\"\n    PROJECT = \"PROJECT\"\n    PROJECT_LIST = \"PROJECT_LIST\"\n    PROJECT_TASK = \"PROJECT_TASK\"\n    PROJECT_TASK_ATTACHMENT = \"PROJECT_TASK_ATTACHMENT\"\n    PROJECT_TASK_OWNER = \"PROJECT_TASK_OWNER\"\n    PROXIER_EMAIL = \"PROXIER_EMAIL\"\n    PUBLIC_EMBED_URL = \"PUBLIC_URL\"\n    PUBLICATION = \"PUBLICATION\"\n    REPOSITORY = \"REPOSITORY\"\n    REPOSITORY_AUTHORIZATION = \"REPOSITORY_AUTHORIZATION\"\n    ROLE = \"ROLE\"\n    SEGMENT = \"SEGMENT\"\n    SSO_PAGE = \"SSO_PAGE\"\n    SUBSCRIBER = \"PROXY_USER\"\n    USER = \"USER\"\n    USER_STATE = \"USER_STATE\"\n    VARIABLE = \"VARIABLE\"\n    VARIABLE_CONTROL = \"VARIABLE_CONTROL\"\n    NOTEBOOK_VIEW = \"CONTAINER_VIEW\"\n    VIEW = \"VIEW\"\n    VIRTUAL_USER = \"VIRTUAL_USER\"\n    WORKBENCH_AGENT = \"Workbench_AGENT\"\n    WORKBENCH_JOB = \"Workbench_JOB\"\n    WORKBENCH_SCHEDULE = \"Workbench_SCHEDULE\"\n\n\nsource\n\nActivityLog_ObjectType\n\n ActivityLog_ObjectType (value, names=None, module=None, qualname=None,\n                         type=None, start=1)\n\nenumerates valid object types to pass to activity log api\nTo get an updated list of objectTypes run the get_activity_log_object_types function.\nNote: in the ActivityLog_ObjectType enum, some of the entries have been renamed for clarity.\n\nsource\n\n\nDomoActivityLog\n\n DomoActivityLog ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(domo_instance='domo-dojo',\n                                    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"])\n\nal_res = await DomoActivityLog.get_activity_log(\n    auth = token_auth,\n    start_time = start_datetime,\n    end_time = end_datetime,\n    object_type = ActivityLog_ObjectType.ACTIVITY_LOG,\n    maximum =5)\n\npd.DataFrame(al_res)\n\n\n\n\n\n  \n    \n      \n      userName\n      userId\n      userType\n      actorName\n      actorId\n      actionType\n      objectName\n      objectId\n      objectType\n      additionalComment\n      time\n      eventText\n      clientId\n      time_dt\n      date\n    \n  \n  \n    \n      0\n      Jae Wilson1\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson1 logged in. Logged in from IP addre...\n      1679017419844\n      Logged in\n      None\n      2023-03-17 01:43:39.844\n      2023-03-17\n    \n    \n      1\n      Jae Wilson1\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      test - updated via dl 2023-03-17\n      663516735\n      USER\n      \n      1679017419472\n      Updated user\n      None\n      2023-03-17 01:43:39.472\n      2023-03-17\n    \n    \n      2\n      Jae Wilson1\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson1 logged in. Logged in from IP addre...\n      1679017416430\n      Logged in\n      None\n      2023-03-17 01:43:36.430\n      2023-03-17\n    \n    \n      3\n      Jae Wilson1\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      super_admin\n      810756122\n      ROLE\n      Jae Wilson1 updated role super_admin.  Role de...\n      1679017415548\n      Updated role\n      None\n      2023-03-17 01:43:35.548\n      2023-03-17\n    \n    \n      4\n      Jae Wilson1\n      1893952720\n      USER\n      \n      0\n      CHANGED_ROLE\n      Bryan Van Kampen\n      587894148\n      USER\n      Jae Wilson1 changed role for Bryan Van Kampen....\n      1679017414650\n      Changed user role\n      None\n      2023-03-17 01:43:34.650\n      2023-03-17"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "",
    "text": "domolibrary is a Python package that provides a OOP (class-based) and a functional approach to interacting with Domo’s API framework.\nAll accessed APIs are documented under DataCrew’s Domo Documentation page.\nThis library was created by DataCrew contributor Jae Wilson."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "Install",
    "text": "Install\nThe DataCrew team is hard at work expanding the list of available classes and routes. We have a ton of work completed, it’s just a matter of migrating and documenting the code into this library.\npip install domolibrary"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "How to use",
    "text": "How to use\n\nAuthentication\nFor each task, consider the appropriate DomoAuth mechanism. In most cases DomoFullAuth or DomoTokenAuth will be appropriate as this library predominately accesses private APIs.\nAny Public routes or methods will be labeled appropriately in which case you should use DomoDeveloperAuth. Public routes are APIs enumerated and documented under Developer.Domo.com.\nTypically each project will begin with configuring an auth object. If you are accessing multiple Domo instances, you’ll probably need multiple auth objects.\n\n# configure an auth method\nimport os\nimport domolibrary.client.DomoAuth as dmda\n\ntoken_auth = dmda.DomoTokenAuth( domo_instance = 'domo-dojo', domo_access_token = os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\n\n\nOption 1: class based programming\nIn this project domo entities, DomoActivityLog, DomoDataset are all prefixed ‘Domo’ and can be found in the classes folder. Each class method will call one or more routes. Each route will interact with one and only one API.\nAlthough most methods will be standard methods that will be called after creating an instance of the class, some methods will be classmethods which return an instance of the class.\nIn the example below, DomoDataset.get_from_id is a classmethod.\nNote: DomoLibrary uses the asynchronous aiohttp requests library to offer users the ability to write concurrently executing code.\n\n# import domolibrary.classes.DomoDataset as dmds\n\n# # this is a class method\n# domo_ds = await dmds.DomoDataset.get_from_id(auth=token_auth, dataset_id=os.environ['DOJO_DATASET_ID'])\n# domo_ds\n\nOnce instantiated, you can call methods to interact with that object. You typically won’t have to pass auth creds again because they are saved to the object.\nIn the example below we are retrieving the DomoDataset_Schema which consists of subclass DomoDataset_Schema_Column using the DomoDataset_Schema.get method.\nWe take the approach of where possible converting dictionaries from Domo APIs into classes because it provides greater predictability when users are creating integrations between platforms (ex. Domo to Trello).\n\n# await domo_ds.schema.get()\n\nTypically all information about an entity is saved in the object\n\n# domo_ds.__dict__\n\n\n\nOption 2 functional programming\nAlthough classes add a pretty wrapper for interacting with Domo APIs, users can opt to interact directly with APIs by way of routes.\nAll route functions will exclusively call one API and will always return a ResponseGetData object OR raise an Exception if appropriate.\nFor example we can implement similar functionality as the Option 1 example by calling the get_dataset_by_id function.\n\nimport domolibrary.routes.dataset as dataset_routes\n\nds_res = await dataset_routes.get_dataset_by_id( auth = token_auth, dataset_id = os.environ['DOJO_DATASET_ID'])\nds_res\n\nResponseGetData(status=200, response={'id': '04c1574e-c8be-4721-9846-c6ffa491144b', 'displayType': 'domo-jupyterdata', 'dataProviderType': 'domo-jupyterdata', 'type': 'Jupyter', 'name': 'domo_kbs', 'owner': {'id': '1893952720', 'name': 'Jae Wilson', 'type': 'USER', 'group': False}, 'status': 'SUCCESS', 'created': 1668379680000, 'lastTouched': 1668385822000, 'lastUpdated': 1668385822045, 'rowCount': 1185, 'columnCount': 7, 'cardInfo': {'cardCount': 0, 'cardViewCount': 0}, 'properties': {'formulas': {'formulas': {}}}, 'state': 'SUCCESS', 'validConfiguration': True, 'validAccount': True, 'streamId': 825, 'transportType': 'API', 'adc': False, 'adcExternal': False, 'cloudId': 'domo', 'cloudName': 'Domo', 'permissions': 'READ_WRITE_DELETE_SHARE_ADMIN', 'hidden': False, 'tags': '[\"developer_documentation\",\"hackercore\"]', 'scheduleActive': True, 'cryoStatus': 'ADRENALINE'}, is_success=True)\n\n\nResponseGetData will always include a boolean is_success, the API status, and raw API response.\nTypically the route methods will not alter the response unless the API does not include a descriptive response (ex, routes.dataset.set_dataset_tags does not return a response so we artificially alter the response in the function.)\n\n[(prop, type(getattr(ds_res , prop))) for prop in dir(ds_res) if not prop.startswith('_')]\n\n[('auth', domolibrary.client.DomoAuth.DomoTokenAuth),\n ('is_success', bool),\n ('response', dict),\n ('set_response', method),\n ('status', int)]\n\n\n\nds_res.response\n\n{'id': '04c1574e-c8be-4721-9846-c6ffa491144b',\n 'displayType': 'domo-jupyterdata',\n 'dataProviderType': 'domo-jupyterdata',\n 'type': 'Jupyter',\n 'name': 'domo_kbs',\n 'owner': {'id': '1893952720',\n  'name': 'Jae Wilson',\n  'type': 'USER',\n  'group': False},\n 'status': 'SUCCESS',\n 'created': 1668379680000,\n 'lastTouched': 1668385822000,\n 'lastUpdated': 1668385822045,\n 'rowCount': 1185,\n 'columnCount': 7,\n 'cardInfo': {'cardCount': 0, 'cardViewCount': 0},\n 'properties': {'formulas': {'formulas': {}}},\n 'state': 'SUCCESS',\n 'validConfiguration': True,\n 'validAccount': True,\n 'streamId': 825,\n 'transportType': 'API',\n 'adc': False,\n 'adcExternal': False,\n 'cloudId': 'domo',\n 'cloudName': 'Domo',\n 'permissions': 'READ_WRITE_DELETE_SHARE_ADMIN',\n 'hidden': False,\n 'tags': '[\"developer_documentation\",\"hackercore\"]',\n 'scheduleActive': True,\n 'cryoStatus': 'ADRENALINE'}\n\n\n\n\nAccess Paginated APIs using the Looper\nA hidden advantage of using the DomoLibrary is that paginated API requests are baked into the route’s definition.\nConsider query_dataset_private from the routes.dataset.\nInside this function we are using looper from client.get_data to paginate over the API response."
  },
  {
    "objectID": "projects/posts/2023-02-02_DojoSQL/index.html",
    "href": "projects/posts/2023-02-02_DojoSQL/index.html",
    "title": "Tutorial - Extract SQL from a Dataflow",
    "section": "",
    "text": "# pip install --upgrade  domolibrary\n# pip install sqlparse\n# pip install sql-metadata\n\n\n\nConfigure a DomoAuth object that will be used to interact with DomoDatasets\nFor this project we must use DomoFullAuth because the bootstrap API will not accept token auth\n\nimport os\nDOMO_INSTANCE = 'domo-dojo'\nDOMO_USERNAME = 'jae@onyxreporting.com'\nDOMO_PASSWORD = os.environ['DOJO_PASSWORD']\nSQL_DATAFLOW_ID = 70\n\n\nimport domolibrary.client.DomoAuth as dmda\n\nasync def generate_auth(domo_instance, domo_username, domo_password) -> dmda.DomoAuth:\n    \"\"\"receive auth credentials, generate and test an auth object\"\"\"\n    \n    print(f\"⚙️ generate_auth:  retrieving config data from {domo_instance} ⚙️\")\n\n    auth = dmda.DomoFullAuth(domo_username=domo_username,\n                                    domo_password=domo_password,\n                                    domo_instance=domo_instance)\n\n    #confirm we can get a valid auth token\n    await auth.get_auth_token()\n\n    if not auth.token:\n        raise Exception('💀 generate_auth: Error retrieving Auth Token')\n\n    if auth.token:\n        print('🌼 generate_auth:  success retrieving Auth Token')\n    \n    return auth\n\n# test\ntest_auth = await generate_auth(domo_instance = DOMO_INSTANCE, domo_password = DOMO_PASSWORD, domo_username = DOMO_USERNAME)\n\n⚙️ generate_auth:  retrieving config data from domo-dojo ⚙️\n🌼 generate_auth:  success retrieving Auth Token\n\n\n\n\n\nConfigure a DomoDataflow\n\nimport domolibrary.classes.DomoDataflow as dmdf\n\nasync def generate_dataflow(dataflow_id:str, auth :dmda.DomoAuth):\n    \"\"\"generates a DomoDataset class object from a dataset_id\"\"\"\n\n    return await dmdf.DomoDataflow.get_from_id(dataflow_id=dataflow_id, auth=auth)\n\n#test\ndf = await generate_dataflow(dataflow_id=SQL_DATAFLOW_ID, auth=test_auth)\n\n\n\n\nDomoDataflow_Action definitions are embeded in the DomoDataflow.actions property.\nThe DomoDataflow_Action class only captures a portion of the available properties across all the different action types, so this can be extended as needed.\nSQL statements are captured in DomoDataflow_Action.sql and can therefore be parsed or reformatted for presentation in other documentation tools. In the example below we use the [sqlparse(https://github.com/andialbrecht/sqlparse]) and [sql_metadata(https://github.com/macbre/sql-metadata)] library to parse and present a dataflow.\n\nimport sqlparse\nimport sql_metadata as sqlmd\nimport domolibrary.classes.DomoBootstrap as dmbsr\nfrom pprint import pprint\n\ndef process_actions(domo_dataflow : dmdf.DomoDataflow, debug_api : bool = False) :\n    \"\"\"exctract SQL from actions\"\"\"\n\n    domo_actions = domo_dataflow.actions\n\n    if not domo_actions:\n        return\n\n    clean_sql = []\n    \n    for action in domo_actions:\n        sql = action.sql\n\n        # not all domo actions will contain sql.\n        if not sql:\n            continue\n\n        # alter according to your needs\n        clean_sql.append({\n            'transform_sql': sqlparse.format( sql, reindent_aligned=True, keyword_case='upper') ,\n            'referenced_tables': \", \".join(sqlmd.Parser(sql).tables),\n            'target_table': action.name\n        })\n\n    return clean_sql\n\nres = process_actions(domo_dataflow = df)\npprint(res)\n\n[{'referenced_tables': 'domostats_people',\n  'target_table': 't_1',\n  'transform_sql': 'SELECT `Display Name`,\\n'\n                   '       `User ID` , @row := @row+1 AS id , @isReset := CASE '\n                   'WHEN @iter = @rowCounter THEN 1\\n'\n                   '            ELSE 0\\n'\n                   '             END isReset , @group := @isReset + @group AS '\n                   'rowGroup , @iter := CASE WHEN @isReset = 1 THEN 1\\n'\n                   '            ELSE @iter + 1\\n'\n                   '             END iter , @rowCounter := CASE WHEN @isReset '\n                   '= 1 THEN FLOOR(RAND() * (7-3) + 3)\\n'\n                   '            ELSE @rowCounter\\n'\n                   '             END numChildren\\n'\n                   '  FROM `domostats_people` p ,\\n'\n                   '       (\\n'\n                   '        SELECT @row:= 0,@rowCounter:= 1, @iter := 1, '\n                   '@isReset := 0 , @group := 0\\n'\n                   '       ) r'},\n {'referenced_tables': 't_1',\n  'target_table': 'reportsto',\n  'transform_sql': 'SELECT b.`User ID` AS userID,\\n'\n                   \"       'reportsTo' AS Action,\\n\"\n                   '       a.`User ID` AS bodyID\\n'\n                   '  FROM t_1 a\\n'\n                   '  JOIN t_1 b\\n'\n                   '    ON a.id = b.`rowGroup`\\n'\n                   ' WHERE a.`User ID` <> b.`User ID`\\n'\n                   ' UNION SELECT b.`User ID` AS userID,\\n'\n                   \"       'directReports' AS Action,\\n\"\n                   '       a.`User ID` AS bodyID\\n'\n                   '  FROM t_1 a\\n'\n                   '  JOIN t_1 b\\n'\n                   '    ON b.id = a.`rowGroup`\\n'\n                   ' WHERE a.`User ID` <> b.`User ID`'},\n {'referenced_tables': 'reportsto',\n  'target_table': 'domoStats_people_reports',\n  'transform_sql': 'SELECT *\\n  FROM `reportsto`'}]"
  },
  {
    "objectID": "projects/posts/2023-02-02_DojoFeatures/index.html",
    "href": "projects/posts/2023-02-02_DojoFeatures/index.html",
    "title": "Tutorial - Generate your Features list from the Bootstrap API",
    "section": "",
    "text": "# pip install --upgrade  domolibrary\n\n\n\nConfigure a DomoAuth object that will be used to interact with DomoDatasets\nFor this project we must use DomoFullAuth because the bootstrap API will not accept token auth\n\nimport os\nDOMO_INSTANCE = 'domo-dojo'\nDOMO_USERNAME = 'jae@onyxreporting.com'\nDOMO_PASSWORD = os.environ['DOJO_PASSWORD']\nFEATURES_DATASET_ID = '44c5af30-ea04-49e4-9d7a-529afd223590'\n\n\nimport domolibrary.client.DomoAuth as dmda\n\nasync def generate_auth(domo_instance, domo_username, domo_password) -> dmda.DomoAuth:\n    \"\"\"receive auth credentials, generate and test an auth object\"\"\"\n    \n    print(f\"⚙️ generate_auth:  retrieving config data from {domo_instance} ⚙️\")\n\n    auth = dmda.DomoFullAuth(domo_username=domo_username,\n                                    domo_password=domo_password,\n                                    domo_instance=domo_instance)\n\n    #confirm we can get a valid auth token\n    await auth.get_auth_token()\n\n    if not auth.token:\n        raise Exception('💀 generate_auth: Error retrieving Auth Token')\n\n    if auth.token:\n        print('🌼 generate_auth:  success retrieving Auth Token')\n    \n    return auth\n\n# test\ntest_auth = await generate_auth(domo_instance = DOMO_INSTANCE, domo_password = DOMO_PASSWORD, domo_username = DOMO_USERNAME)\n\n⚙️ generate_auth:  retrieving config data from domo-dojo ⚙️\n🌼 generate_auth:  success retrieving Auth Token\n\n\n\n\n\nConfigure a DomoDataset that will receive the Bootstrap dataframe from DomoBootstrap\nNote, the schema of the dataset must match the schema of the dataframe being uploaded or the dataset won’t index. You can alter schema using the “Schema Management” tool from the Domo Governance Toolkit or java cli.\n\nimport domolibrary.classes.DomoDataset as dmds\n\nasync def generate_dataset(dataset_id:str, auth :dmda.DomoAuth):\n    \"\"\"generates a DomoDataset class object from a dataset_id\"\"\"\n\n    return await dmds.DomoDataset.get_from_id(dataset_id = dataset_id, auth = auth)\n\n#test\nawait generate_dataset(dataset_id = FEATURES_DATASET_ID, auth = test_auth)\n\nDomoDataset(id='44c5af30-ea04-49e4-9d7a-529afd223590', display_type='api', data_provider_type=None, name='demo_instance_features', description=None, row_count=361, column_count=7, stream_id=911, owner=DictDot(id='1893952720', name='Jae Wilson', type='USER', group=False), formula=DictDot(), schema=DomoDataset_Schema(dataset=..., columns=[]))\n\n\n\n\n\nRetrieve your feature list using DomoBootstrap.get_features() and format it as a dataframe\n\nimport pandas as pd \nimport domolibrary.classes.DomoBootstrap as dmbsr\n\nasync def get_bootstrap(auth, debug_api : bool = False) -> pd.DataFrame:\n    \"\"\"generates a dataframe of bootstrap_features\"\"\"\n\n    domo_bsr = dmbsr.DomoBootstrap(auth = auth)\n\n    bsr_features = await domo_bsr.get_features(debug_api = debug_api)\n\n    bsr_features_df = pd.DataFrame(bsr_features)\n    bsr_features_df['instance'] = auth.domo_instance\n\n    return bsr_features_df\n\n# test\nupload_df = await get_bootstrap(test_auth)\nupload_df[0:5]\n\n\n\n\n\n  \n    \n      \n      id\n      name\n      label\n      type\n      purchased\n      enabled\n      instance\n    \n  \n  \n    \n      0\n      4\n      search\n      \n      STANDARD\n      False\n      True\n      domo-dojo\n    \n    \n      1\n      5\n      launcher\n      \n      PREMIUM\n      True\n      True\n      domo-dojo\n    \n    \n      2\n      9\n      profile-reminder\n      \n      STANDARD\n      False\n      True\n      domo-dojo\n    \n    \n      3\n      17\n      enableSwapDatasource\n      \n      STANDARD\n      False\n      True\n      domo-dojo\n    \n    \n      4\n      19\n      up\n      \n      STANDARD\n      True\n      True\n      domo-dojo"
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Code Samples and Projects",
    "section": "",
    "text": "Tutorial - Extract SQL from a Dataflow\n\n\n\n\n\n\n\nInstance Configuration\n\n\nDataflow\n\n\n\n\n\n\n\n\n\n\n\nFeb 2, 2023\n\n\nJae Wilson\n\n\n\n\n\n\n\n\nTutorial - Generate your Features list from the Bootstrap API\n\n\n\n\n\n\n\nInstance Configuration\n\n\nDomo Features\n\n\n\n\n\n\n\n\n\n\n\nFeb 2, 2023\n\n\nJae Wilson\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "routes/dataset.html",
    "href": "routes/dataset.html",
    "title": "Dataset Routes",
    "section": "",
    "text": "source\n\n\n\n DatasetNotFoundError (dataset_id, domo_instance)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\n\n\n query_dataset_private (auth:domolibrary.client.DomoAuth.DomoAuth,\n                        dataset_id:str, sql:str,\n                        session:Optional[httpx.AsyncClient]=None,\n                        loop_until_end:bool=False, limit=100, skip=0,\n                        maximum=100, debug_api:bool=False,\n                        debug_loop:bool=False, timeout:int=10)\n\nexecute SQL queries against private APIs, requires DomoFullAuth or DomoTokenAuth\n\nsource\n\n\n\n\n query_dataset_public\n                       (dev_auth:domolibrary.client.DomoAuth.DomoDeveloper\n                       Auth, dataset_id:str, sql:str,\n                       session:httpx.AsyncClient, debug_api:bool=False)\n\nquery for hitting public apis, requires client_id and secret authentication\n\nsource\n\n\n\n\n QueryRequestError (dataset_id, domo_instance, sql)\n\nCommon base class for all non-exit exceptions.\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nsql = f\"SELECT * FROM TABLE\"\n\nds_res = await query_dataset_private(\n    dataset_id=os.environ[\"DOJO_DATASET_ID\"],\n    auth=token_auth,\n    sql=sql,\n    skip=42,\n    maximum=5,\n    loop_until_end=False,\n)\npd.DataFrame(ds_res.response)\n\n\n\n\n\n  \n    \n      \n      objectID\n      url\n      Title\n      article\n      views\n      created_dt\n      published_dt\n    \n  \n  \n    \n      0\n      000004790\n      https://domo-support.domo.com/s/article/360046...\n      Starting, Stopping, and Restarting the Workben...\n      Important:  Support for Workbench 4 ended on ...\n      39\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00\n    \n    \n      1\n      000004796\n      https://domo-support.domo.com/s/article/360047...\n      Understanding the Workbench 4 User Interface\n      Important:  Support for Workbench 4 ended on ...\n      56\n      2022-10-24T22:30:00\n      2022-10-24T22:40:00\n    \n    \n      2\n      000004773\n      https://domo-support.domo.com/s/article/360046...\n      Using the External Process File Provider in Wo...\n      Important:  Support for Workbench 4 ended on ...\n      20\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00\n    \n    \n      3\n      000004798\n      https://domo-support.domo.com/s/article/360046...\n      Workbench 4 FAQs\n      Important:  Support for Workbench 4 ended on ...\n      48\n      2022-10-24T22:30:00\n      2022-10-24T22:40:00\n    \n    \n      4\n      000004800\n      https://domo-support.domo.com/s/article/360047...\n      Workbench 4 Overview\n      Important:  Support for Workbench 4 ended on ...\n      40\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00"
  },
  {
    "objectID": "routes/dataset.html#dataset-properties",
    "href": "routes/dataset.html#dataset-properties",
    "title": "Dataset Routes",
    "section": "Dataset Properties",
    "text": "Dataset Properties\n\nsource\n\nget_dataset_by_id\n\n get_dataset_by_id (dataset_id:str,\n                    auth:Optional[domolibrary.client.DomoAuth.DomoAuth]=No\n                    ne, debug_api:bool=False,\n                    session:Optional[httpx.AsyncClient]=None)\n\nretrieve dataset metadata\n\nimport os\nimport pandas as pd\n\ntry:\n    token_auth = dmda.DomoTokenAuth(\n        domo_instance=\"domo-dojo\",\n        domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    )\n\n    await get_dataset_by_id(dataset_id=123, auth=token_auth)\n\nexcept DatasetNotFoundError as e:\n    print(e)\n\ndataset - 123 not found in domo-dojo\n\n\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_res = await get_dataset_by_id(\n    dataset_id=os.environ[\"DOJO_DATASET_ID\"], auth=token_auth\n)\npd.DataFrame([ds_res.response])\n\n\n\n\n\n  \n    \n      \n      id\n      displayType\n      dataProviderType\n      type\n      name\n      owner\n      status\n      created\n      lastTouched\n      lastUpdated\n      rowCount\n      columnCount\n      cardInfo\n      properties\n      state\n      validConfiguration\n      validAccount\n      streamId\n      transportType\n      adc\n      adcExternal\n      cloudId\n      cloudName\n      permissions\n      hidden\n      tags\n      scheduleActive\n      cryoStatus\n    \n  \n  \n    \n      0\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      domo-jupyterdata\n      domo-jupyterdata\n      Jupyter\n      domo_kbs\n      {'id': '1893952720', 'name': 'Jae Wilson1', 't...\n      SUCCESS\n      1668379680000\n      1668385822000\n      1668385822045\n      1185\n      7\n      {'cardCount': 0, 'cardViewCount': 0}\n      {'formulas': {'formulas': {}}}\n      SUCCESS\n      True\n      True\n      825\n      API\n      False\n      False\n      domo\n      Domo\n      READ_WRITE_DELETE_SHARE_ADMIN\n      False\n      [\"Mar-17-2023 01:43\",\"developer_documentation\"...\n      True\n      ADRENALINE\n    \n  \n\n\n\n\n\nsource\n\n\nget_schema\n\n get_schema (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_id:str,\n             debug_api:bool=False)\n\nretrieve the schema for a dataset\n\nsample implementation of get_schema\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_res = await get_schema(dataset_id=os.environ[\"DOJO_DATASET_ID\"], auth=token_auth)\npd.DataFrame(ds_res.response)\n\n\n\n\n\n  \n    \n      \n      name\n      tables\n      dataSourceId\n      url\n      queryEndpoint\n      progressEndpoint\n      indexEndpoint\n      deleteEndpoint\n      versionId\n    \n  \n  \n    \n      0\n      domo_kbs\n      {'columns': [{'name': 'objectID', 'id': 'objec...\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      /schemas/853832B128D75BCE\n      /query/mmmm-0012-0200/04c1574e-c8be-4721-9846-...\n      /index/mmmm-0012-0200/04c1574e-c8be-4721-9846-...\n      /index/mmmm-0012-0200/04c1574e-c8be-4721-9846-...\n      /delete/mmmm-0012-0200/04c1574e-c8be-4721-9846...\n      3\n    \n  \n\n\n\n\n\n# retrieve schema from response\npd.DataFrame(ds_res.response.get(\"tables\")[0].get(\"columns\"))\n\n\n\n\n\n  \n    \n      \n      name\n      id\n      type\n      visible\n      order\n    \n  \n  \n    \n      0\n      objectID\n      objectID\n      STRING\n      True\n      0\n    \n    \n      1\n      url\n      url\n      STRING\n      True\n      0\n    \n    \n      2\n      Title\n      Title\n      STRING\n      True\n      0\n    \n    \n      3\n      article\n      article\n      STRING\n      True\n      0\n    \n    \n      4\n      views\n      views\n      LONG\n      True\n      0\n    \n    \n      5\n      created_dt\n      created_dt\n      DATETIME\n      True\n      0\n    \n    \n      6\n      published_dt\n      published_dt\n      DATETIME\n      True\n      0\n    \n  \n\n\n\n\n\nsource\n\n\n\nset_dataset_tags\n\n set_dataset_tags (auth:domolibrary.client.DomoAuth.DomoFullAuth,\n                   tag_ls:[<class'str'>], dataset_id:str,\n                   debug_api:bool=False,\n                   session:Optional[httpx.AsyncClient]=None,\n                   return_raw:bool=False)\n\nREPLACE tags on this dataset with a new list\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\ntag_ls = [\"hackercore\", \"developer_documentation\"]\n\nawait set_dataset_tags(\n    auth=token_auth,\n    tag_ls=tag_ls,\n    dataset_id=os.environ[\"DOJO_DATASET_ID\"],\n    debug_api=False,\n    return_raw=False,\n)\n\nResponseGetData(status=200, response='Dataset 04c1574e-c8be-4721-9846-c6ffa491144b tags updated to [hackercore, developer_documentation]', is_success=True)"
  },
  {
    "objectID": "routes/dataset.html#upload-data",
    "href": "routes/dataset.html#upload-data",
    "title": "Dataset Routes",
    "section": "Upload Data",
    "text": "Upload Data\n\noverview\nIn the URL, parts refers to the multi-part API and is unrelated to the partitions concept. The multi-part API was designed to allow sending multiple streams of Data into a data_version simultaneously.\nIn stage 1, the values passed in the Body will be superseded by values in the COMMIT (stage 3), so best practices is to not populate values here.\nThe response includes an uploadId, which must be stored and passed to the URL of the subsequent upload request (stages 2 and 3).\n\n\nurl params\nThe dataTag parameter allows users to UPDATE or REPLACE a datatag (partition)\nNOTE: restateDataTag is largely deprecated // exists for backward compatibility\n\n\nbody params\nThe appendId parameter accepts “latest” or “None”\nlatest will APPEND the data version to the dataset\n\nsource\n\n\nUploadDataError\n\n UploadDataError (stage_num:int, dataset_id:str, domo_instance:str)\n\nraise if unable to upload data to Domo\n\nsource\n\n\nupload_dataset_stage_1\n\n upload_dataset_stage_1 (auth:domolibrary.client.DomoAuth.DomoAuth,\n                         dataset_id:str, partition_tag:str=None,\n                         session:Optional[httpx.AsyncClient]=None,\n                         debug_api:bool=False)\n\npreps dataset for upload by creating an upload_id (upload session key) pass to stage 2 as a parameter\n\nsource\n\n\nupload_dataset_stage_2_file\n\n upload_dataset_stage_2_file (auth:domolibrary.client.DomoAuth.DomoAuth,\n                              dataset_id:str, upload_id:str,\n                              data_file:Optional[_io.TextIOWrapper]=None,\n                              session:Optional[httpx.AsyncClient]=None,\n                              part_id:str=2, debug_api:bool=False)\n\n\nsource\n\n\nupload_dataset_stage_2_df\n\n upload_dataset_stage_2_df (auth:domolibrary.client.DomoAuth.DomoAuth,\n                            dataset_id:str, upload_id:str,\n                            upload_df:pandas.core.frame.DataFrame,\n                            session:Optional[httpx.AsyncClient]=None,\n                            part_id:str=2, debug_api:bool=False)\n\n\nsource\n\n\nupload_dataset_stage_3\n\n upload_dataset_stage_3 (auth:domolibrary.client.DomoAuth.DomoAuth,\n                         dataset_id:str, upload_id:str,\n                         session:Optional[httpx.AsyncClient]=None,\n                         update_method:str='REPLACE',\n                         partition_tag:str=None, is_index:bool=False,\n                         debug_api:bool=False)\n\ncommit will close the upload session, upload_id. this request defines how the data will be loaded into Adrenaline, update_method has optional flag for indexing dataset.\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_id = \"cbae0e0c-a92d-4a4c-8d0c-c9ccd38fe928\"\n\n# await get_schema(dataset_id= ds_id, auth=token_auth)\n\ndf = pd.DataFrame([{\"col_a\": \"a\", \"col_b\": \"b\", \"col_c\": \"c\"}])\n\n\ns1_res = await upload_dataset_stage_1(\n    auth=token_auth, dataset_id=ds_id, partition_tag=None, debug_api=False\n)\n\nupload_id = s1_res.response.get(\"uploadId\")\nupload_id\n\ns2_res = await upload_dataset_stage_2_df(\n    auth=token_auth,\n    dataset_id=ds_id,\n    upload_id=upload_id,\n    upload_df=df,\n    part_id=2,\n    debug_api=False,\n)\n\n\ns3_res = await upload_dataset_stage_3(\n    auth=token_auth,\n    dataset_id=ds_id,\n    upload_id=upload_id,\n    update_method=\"REPLACE\",  # accepts REPLACE or APPEND\n    is_index=True,  # index after uploading\n)\n\ns3_res.is_success\n\nTrue\n\n\n\nsource\n\n\nindex_dataset\n\n index_dataset (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_id:str,\n                session:Optional[httpx.AsyncClient]=None,\n                debug_api:bool=False)\n\nmanually index a dataset\n\nsource\n\n\nindex_status\n\n index_status (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_id:str,\n               index_id:str, session:Optional[httpx.AsyncClient]=None,\n               debug_api:bool=False)\n\nget the completion status of an index"
  },
  {
    "objectID": "routes/dataset.html#working-with-partitions",
    "href": "routes/dataset.html#working-with-partitions",
    "title": "Dataset Routes",
    "section": "Working with Partitions",
    "text": "Working with Partitions\n\nsource\n\nlist_partitions\n\n list_partitions (auth:domolibrary.client.DomoAuth.DomoAuth,\n                  dataset_id:str, body:dict=None,\n                  session:httpx.AsyncClient=None, debug_api:bool=False,\n                  debug_loop:bool=False)\n\n\nsource\n\n\ngenerate_list_partitions_body\n\n generate_list_partitions_body (limit=100, offset=0)\n\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ndataset_id = \"d2b21660-4ba8-400c-badf-aeef5a9abae1\"\n\nres = await list_partitions(auth=token_auth, dataset_id=dataset_id)\n\nds_partition_ls = res.response\n\npd.DataFrame(ds_partition_ls[0:5])\n\n\n\n\n\n  \n    \n      \n      dataId\n      partitionId\n      dateCompleted\n      rowCount\n    \n  \n  \n    \n      0\n      372\n      2013-07-02\n      2023-01-24T14:27:21.000+00:00\n      1\n    \n    \n      1\n      373\n      2013-07-01\n      2023-01-24T14:27:21.000+00:00\n      1\n    \n    \n      2\n      354\n      2013-07-20\n      2023-01-24T14:27:20.000+00:00\n      1\n    \n    \n      3\n      355\n      2013-07-19\n      2023-01-24T14:27:20.000+00:00\n      1\n    \n    \n      4\n      356\n      2013-07-18\n      2023-01-24T14:27:20.000+00:00\n      1\n    \n  \n\n\n\n\n\nsource\n\n\ncreate\n\n create (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_name:str,\n         dataset_type:str='api', session:httpx.AsyncClient=None,\n         schema:dict=None, debug_api:bool=False)\n\n\nsource\n\n\ngenerate_create_dataset_body\n\n generate_create_dataset_body (dataset_name:str, dataset_type:str='API',\n                               schema:dict=None)\n\n\nsample implementation of create dataset\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\n# await create(dataset_name = 'hello world', dataset_type = 'api', auth = token_auth)\n\n\n# # Delete partition has 3 stages\n# # Stage 1. This marks the data version associated with the partition tag as deleted.  It does not delete the partition tag or remove the association between the partition tag and data version.  There should be no need to upload an empty file – step #3 will remove the data from Adrenaline.\n# #| export\n# async def delete_partition_stage_1(full_auth: DomoFullAuth,\n#                                    dataset_id: str,\n#                                    dataset_partition_id: str,\n#                                    session: httpx.AsyncClient = None,\n#                                    debug: bool = False):\n\n#     #url = f'https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/partition/{dataset_partition_id}'\n#     # update on 9/9/2022 based on the conversation with Greg Swensen\n#     url = f'https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/tag/{dataset_partition_id}/data'\n\n#     return await get_data(\n#         auth=full_auth,\n#         method=\"DELETE\",\n#         url=url,\n#         session=session,\n#         debug=debug\n#     )\n# # Stage 2. This will remove the partition association so that it doesn’t show up in the list call.  Technically, this is not required as a partition against a deleted data version will not count against the 400 partition limit, but as the current partitions api doesn’t make that clear, cleaning these up will make it much easier for you to manage.\n\n\n# #| export\n# async def delete_partition_stage_2(full_auth: DomoFullAuth,\n#                                    dataset_id: str,\n#                                    dataset_partition_id: str,\n#                                    session: httpx.AsyncClient = None,\n#                                    debug: bool = False):\n\n#     url = f'https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/partition/{dataset_partition_id}'\n\n#     return await get_data(\n#         auth=full_auth,\n#         method=\"DELETE\",\n#         url=url,\n#         session=session,\n#         debug=debug\n#     )\n\n\nsource\n\n\n\ndelete\n\n delete (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_id:str,\n         session:httpx.AsyncClient=None, debug_api:bool=False)"
  },
  {
    "objectID": "routes/instance_config.html",
    "href": "routes/instance_config.html",
    "title": "Instance Config Routes",
    "section": "",
    "text": "source\n\nget_allowlist\n\n get_allowlist (auth:domolibrary.client.DomoAuth.DomoFullAuth,\n                session:httpx.AsyncClient=None, debug_api:bool=False,\n                return_raw:bool=False)\n\n\nsample implementation of get_allowlist with the wrong auth type\n\nimport os\nimport requests\n\nauth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntry:\n    await get_allowlist(auth=auth)\nexcept dmda.InvalidAuthTypeError as e:\n    print(e)\n\nget_allowlist: This API rquires DomoFullAuth at domo-dojo\n\n\n\n\nsample implementation of get_allowlist with the correct auth type\n\nimport os\nimport requests\n\nauth = dmda.DomoFullAuth(\n    domo_instance=\"domo-dojo\",\n    domo_username=\"jae@onyxreporting.com\",\n    domo_password=os.environ[\"DOJO_PASSWORD\"],\n)\n\nres = await get_allowlist(auth=auth)\n\nres\n\nResponseGetData(status=200, response={'addresses': ['0.0.0.0/0', '192.168.0.1', '40.77.45.151']}, is_success=True)\n\n\n\nsource\n\n\n\nAllowlist_UnableToUpdate\n\n Allowlist_UnableToUpdate (status:int, reason:str, domo_instance:str,\n                           function_name:str='update_allowlist')\n\nbase exception\n\nsource\n\n\nset_allowlist\n\n set_allowlist (auth:domolibrary.client.DomoAuth.DomoAuth,\n                ip_address_ls:list[str], debug_api:bool=False,\n                return_raw:bool=False, session:httpx.AsyncClient=None)\n\ncompanysettings/whitelist API only allows users to SET the allowlist does not allow INSERT or UPDATE\n\nimport os\n\nip_address_ls = [\"0.0.0.0/0\"]\n\nauth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nauth = dmda.DomoFullAuth(\n    domo_instance=\"domo-dojo\",\n    domo_username=\"jae@onyxreporting.com\",\n    domo_password=os.environ[\"DOJO_PASSWORD\"],\n)\n\nres = await set_allowlist(auth=auth, ip_address_ls=ip_address_ls)\nres\n\nResponseGetData(status=200, response='allow list updated from 40.77.45.151', is_success=True)\n\n\n\n# # | export\n# async def update_authorized_domains(\n#     auth: DomoAuth,\n#     authorized_domain_list: list[str],\n#     debug_api: bool = False,\n#     session: httpx.AsyncClient = None,\n# ):\n#     url = f\"https://{auth.domo_instance}.domo.com/api/content/v1/customer-states/authorized-domains\"\n\n#     body = {\"name\": \"authorized-domains\", \"value\": \",\".join(authorized_domain_list)}\n\n#     if debug_api:\n#         print(url)\n\n#     res = await gd.get_data(\n#         auth=auth,\n#         url=url,\n#         method=\"PUT\",\n#         body=body,\n#         log_results=log_results,\n#         debug_api=debug_api,\n#         session=session,\n#     )\n\n#     return res\n\n\n# # | export\n# async def get_authorized_domains(\n#     auth: DomoAuth,\n#     debug_api: bool = False,\n#     log_results: bool = False,\n#     session: httpx.AsyncClient = None,\n# ):\n#     url = f\"https://{auth.domo_instance}.domo.com/api/content/v1/customer-states/authorized-domains\"\n\n#     if debug_api:\n#         print(url)\n\n#     res = await gd.get_data(\n#         auth=auth,\n#         url=url,\n#         method=\"GET\",\n#         log_results=log_results,\n#         debug_api=debug_api,\n#         session=session,\n#     )\n\n#     return res"
  },
  {
    "objectID": "routes/user.html",
    "href": "routes/user.html",
    "title": "User Routes",
    "section": "",
    "text": "GET Users\n\nsource\n\nget_all_users\n\n get_all_users (auth:domolibrary.client.DomoAuth.DomoAuth,\n                debug_api:bool=False)\n\nretrieves all users from Domo\n\nsample implementation of get_all_users\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await get_all_users(auth=token_auth)\npd.DataFrame(res.response[0:5])\n\nos.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n\n'2f4cb212853732ef796abd46077cf1162c0a3ed7cf1ff079'\n\n\n\n\n\n\nSearch Users\nThis series of functions searchse the v1_users_api. The body of the search api can be retrieved by searching admin in the Domo User interface.\n\nsource\n\ngenerate_search_users_body_by_id\n\n generate_search_users_body_by_id (user_ids:list[str])\n\nsearch v1_users_search_api\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nuser_ids\nlist\nlist of user ids to search\n\n\nReturns\ndict\ndict to pass to search v1_users_search_api\n\n\n\n\nsource\n\n\ngenerate_search_users_body_by_email\n\n generate_search_users_body_by_email (user_email_ls:list[str])\n\nsearch v1_users_search_api\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nuser_email_ls\nlist\n\n\n\nReturns\ndict\ndict to pass to search v1_users_search_api\n\n\n\n\nsource\n\n\nprocess_v1_search_users\n\n process_v1_search_users (v1_user_ls:list[dict])\n\nsanitizes the response from v1_users_search API and removes unecessary attributes\n\n\n\n\nType\nDetails\n\n\n\n\nv1_user_ls\nlist\nlist of users from v1_users_search API\n\n\nReturns\nlist\nsanitized list of users.\n\n\n\n\nsource\n\n\nSearchUser_NoResults\n\n SearchUser_NoResults (domo_instance, function_name='search_users',\n                       search_criteria=None)\n\nbase exception\n\nsource\n\n\nsearch_users\n\n search_users (auth:domolibrary.client.DomoAuth.DomoAuth, body:dict,\n               debug_api:bool=False, return_raw:bool=False)\n\n\nsample implementation of search_users\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nsearch_email_body = generate_search_users_body_by_email(\n    user_email_ls=[\"jae@onyxreporting.com\"]\n)\n\nres = await search_users(\n    auth=token_auth, body=search_email_body, return_raw=False, debug_api=False\n)\n\npd.DataFrame(res.response)\n\n\n\n\n\n  \n    \n      \n      id\n      displayName\n      roleId\n      userName\n      emailAddress\n    \n  \n  \n    \n      0\n      1893952720\n      Jae Wilson1\n      1\n      jae@onyxreporting.com\n      jae@onyxreporting.com\n    \n  \n\n\n\n\n\n\n\n\nPublish and Virtual Users\n\nVirtual Users are necessary for assigning PDP policies when publish jobs are created.\n\n\nsource\n\nsearch_virtual_user_by_subscriber_instance\n\n search_virtual_user_by_subscriber_instance\n                                             (auth:domolibrary.client.Domo\n                                             Auth.DomoAuth, subscriber_ins\n                                             tance_ls:list[str],\n                                             debug_api:bool=False)\n\nretrieve virtual users for subscriber instances tied to one publisher\n\nsample of search virtual users by subscriber_instance\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await search_virtual_user_by_subscriber_instance(\n    auth=token_auth, subscriber_instance_ls=[\"domo-dojo\", \"test\"], debug_api=False\n)\n\n\npd.DataFrame(res.response)\n\n\n\n\n\n  \n    \n      \n      id\n      publisherDomain\n      customerId\n      subscriberDomain\n      virtualUserId\n      created\n      activeSubscriptions\n    \n  \n  \n    \n      0\n      2bcabab7-128e-4f47-8219-c8548588d7fc\n      domo-dojo.domo.com\n      mmmm-0012-0200\n      domo-dojo.domo.com\n      fc:ce69e5f0-ab88-46df-94ab-32b5f6dfd4e7\n      1674251102000\n      0\n    \n    \n      1\n      57999e9b-e8a2-48ab-80c6-edf2627b71fc\n      domo-dojo.domo.com\n      mmmm-0012-0200\n      test.domo.com\n      fc:b3d7aaa1-9bc8-4481-9d34-c153a9b91b22\n      1674253476000\n      0\n    \n  \n\n\n\n\n\n\n\n\nCRUD Routes and User Attributes\n\nsource\n\ncreate_user\n\n create_user (auth:domolibrary.client.DomoAuth.DomoAuth, display_name:str,\n              email_address:str, role_id:int, debug_api:bool=False,\n              session:httpx.AsyncClient=None)\n\n\nsource\n\n\nset_user_landing_page\n\n set_user_landing_page (auth:domolibrary.client.DomoAuth.DomoAuth,\n                        user_id:str, page_id:str, debug_api:bool=False)\n\n\nsource\n\n\nreset_password\n\n reset_password (auth:domolibrary.client.DomoAuth.DomoAuth, user_id:str,\n                 new_password:str, debug_api:bool=False)\n\n\nsource\n\n\nrequest_password_reset\n\n request_password_reset (domo_instance:str, email:str, locale='en-us',\n                         debug_api:bool=False,\n                         session:httpx.AsyncClient=None)\n\n\n\nProperties you can PATCH\n\nsource\n\n\nUserProperty\n\n UserProperty (property_type:__main__.UserProperty_Type, values)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nUserProperty_Type\n\n UserProperty_Type (value, names=None, module=None, qualname=None,\n                    type=None, start=1)\n\nAn enumeration.\n\nsource\n\n\ngenerate_patch_user_property_body\n\n generate_patch_user_property_body\n                                    (user_property_ls:[<class'__main__.Use\n                                    rProperty'>])\n\n\nsample implementation of generate_user_property_body\n\nuser_property_ls = [\n    UserProperty(UserProperty_Type.display_name, \"jae myong wilson\"),\n    UserProperty(UserProperty_Type.email_address, \"jae@onyxreporting.com\"),\n    UserProperty(UserProperty_Type.role_id, 1),\n]\n\ngenerate_patch_user_property_body(user_property_ls)\n\n{'attributes': [{'key': 'displayName', 'values': ['jae myong wilson']},\n  {'key': 'emailAddress', 'values': ['jae@onyxreporting.com']},\n  {'key': 'roleId', 'values': [1]}]}\n\n\n\nsource\n\n\n\nupdate_user\n\n update_user (user_id:str,\n              user_property_ls:[<class'__main__.UserProperty'>],\n              auth:domolibrary.client.DomoAuth.DomoAuth=None,\n              debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nuser_property_ls = [\n    UserProperty(UserProperty_Type.display_name, \"test 3\"),\n    UserProperty(UserProperty_Type.email_address, \"test3@test.com\"),\n    UserProperty(UserProperty_Type.role_id, 810756122),\n]\n\nawait update_user(\n    user_id=1681443709, user_property_ls=user_property_ls, auth=token_auth\n)\n\nResponseGetData(status=200, response={'attributes': [{'key': 'id', 'values': [1681443709]}, {'key': 'displayName', 'values': ['test 3']}, {'key': 'userName', 'values': ['test3@test.com']}, {'key': 'emailAddress', 'values': ['test3@test.com']}, {'key': 'modified', 'values': [1679017425800]}, {'key': 'created', 'values': [1664936244000]}, {'key': 'roleId', 'values': [810756122]}, {'key': 'isAnonymous', 'values': [True]}, {'key': 'isSystemUser', 'values': [False]}, {'key': 'isPending', 'values': [True]}, {'key': 'isActive', 'values': [True]}, {'key': 'invitorUserId', 'values': [1893952720]}, {'key': 'avatarKey', 'values': ['/api/content/v1/avatar/USER/1681443709']}], 'id': 1681443709, 'displayName': 'test 3', 'roleId': 810756122, 'userName': 'test3@test.com', 'emailAddress': 'test3@test.com'}, is_success=True)"
  },
  {
    "objectID": "routes/publish.html",
    "href": "routes/publish.html",
    "title": "Publish Routes",
    "section": "",
    "text": "Publications\n\nsource\n\nsearch_publications\n\n search_publications (auth:domolibrary.client.DomoAuth.DomoAuth,\n                      search_term:str=None, limit=100, offset=0,\n                      session:httpx.AsyncClient=None,\n                      debug_api:bool=False)\n\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", \n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await search_publications(auth=token_auth)\n\npd.DataFrame(res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      id\n      name\n      description\n      dataSets\n      pages\n      cards\n      subscribers\n      totalSubscribers\n      invalidSubscribers\n      invalidDatasetSubscribers\n      invalidPageSubscribers\n      invalidCardSubscribers\n      isV2\n      hasDuplicate\n      refreshing\n      executionType\n      executionEstimatedCompletionTime\n      executionStartTime\n      executionEndTime\n    \n  \n  \n    \n      0\n      431005fd-ec85-41fe-88f6-7b888222aec2\n      Variables Example from Domo-Dojo\n      \n      4\n      1\n      34\n      1\n      1\n      0\n      0\n      0\n      0\n      True\n      False\n      False\n      NEW_PUBLICATION\n      1665674300883\n      1665674090889\n      1665674095548\n    \n    \n      1\n      c29b435e-5dcf-4aef-916e-1bcea4d5ef4c\n      Variables From Domo-Dojo\n      \n      4\n      1\n      34\n      0\n      1\n      0\n      0\n      0\n      0\n      True\n      False\n      False\n      NEW_PUBLICATION\n      1665674092715\n      1665673882720\n      1665673891645\n    \n    \n      2\n      794229e9-e724-43c3-9980-53240ba94c25\n      Wills Variables Push\n      \n      5\n      1\n      39\n      1\n      1\n      1\n      0\n      0\n      1\n      True\n      False\n      False\n      NEW_PUBLICATION\n      1666994158307\n      1666993918312\n      1666993927988\n    \n  \n\n\n\n\n\nsource\n\n\nget_publication_by_id\n\n get_publication_by_id (auth:domolibrary.client.DomoAuth.DomoAuth,\n                        publication_id:str,\n                        session:httpx.AsyncClient=None,\n                        debug_api:bool=False)\n\n\nimport os\nimport pandas as pd\n\npublication_id = \"431005fd-ec85-41fe-88f6-7b888222aec2\"\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await get_publication_by_id(publication_id = publication_id,\n                                  auth=token_auth)\n\nres.response\n\n{'id': '431005fd-ec85-41fe-88f6-7b888222aec2',\n 'name': 'Variables Example from Domo-Dojo',\n 'customerId': 'mmmm-0012-0200',\n 'created': 1665674091178,\n 'content': {'id': 'fc120636-c25b-44b3-8769-83f710bb7952',\n  'domain': 'domo-dojo.domo.com',\n  'customerId': 'mmmm-0012-0200',\n  'userId': '1430590895',\n  'type': 'PACKAGE',\n  'updated': 1665674091178,\n  'hash': 'ec05cc31-e4e9-4e71-993a-58fb28918ebe',\n  'publicationId': '431005fd-ec85-41fe-88f6-7b888222aec2'},\n 'description': '',\n 'isV2': True,\n 'hasDuplicate': False,\n 'useDirectContent': True,\n 'type': 'CONTENT',\n 'isBackup': False,\n 'children': [{'id': 'ec909f98-b95b-4b04-b328-f21da172822f',\n   'customerId': '',\n   'created': 1679017426758,\n   'content': {'id': '1e1ed836-51d8-48ab-aa59-61082784db5e',\n    'domain': 'domo-dojo.domo.com',\n    'customerId': '',\n    'userId': '1430590895',\n    'domoObjectId': '1880852133',\n    'type': 'PAGE',\n    'updated': 1679017426758,\n    'hash': 'b731cc8e-c3a6-4192-a6b9-13675864506c'},\n   'isV2': True,\n   'hasDuplicate': False,\n   'useDirectContent': True,\n   'type': 'CONTENT',\n   'isBackup': False,\n   'children': [],\n   'subscriptionAuthorizations': [],\n   'subscribers': []},\n  {'id': '460edf09-cca0-4a4c-bba0-51f82a1a5e84',\n   'customerId': '',\n   'created': 1679017426758,\n   'content': {'id': 'a64634be-5adb-407f-89e7-a74051d4875e',\n    'domain': 'domo-dojo.domo.com',\n    'customerId': '',\n    'userId': '1430590895',\n    'domoObjectId': '8848cdf1-28d4-46e9-93e4-7afb4b5ec1d2',\n    'type': 'DATASET',\n    'updated': 1679017426758,\n    'hash': 'bea6a09b-2857-4337-b43e-9c3807d392fd'},\n   'isV2': True,\n   'hasDuplicate': False,\n   'useDirectContent': True,\n   'type': 'CONTENT',\n   'isBackup': False,\n   'children': [],\n   'subscriptionAuthorizations': [],\n   'subscribers': []},\n  {'id': 'aba70e14-ecf2-4c20-98af-8ffb4d56d183',\n   'customerId': '',\n   'created': 1679017426758,\n   'content': {'id': '6d29dd78-924f-4abe-bc2c-23f39b781523',\n    'domain': 'domo-dojo.domo.com',\n    'customerId': '',\n    'userId': '1430590895',\n    'domoObjectId': 'cf149711-df55-4dc3-a159-59a26d066baa',\n    'type': 'DATASET',\n    'updated': 1679017426758,\n    'hash': '41acbd91-5027-40b6-a9ab-a4cad4efedd8'},\n   'isV2': True,\n   'hasDuplicate': False,\n   'useDirectContent': True,\n   'type': 'CONTENT',\n   'isBackup': False,\n   'children': [],\n   'subscriptionAuthorizations': [],\n   'subscribers': []},\n  {'id': 'b70b4e6f-c4a9-444b-886a-774fa5405472',\n   'customerId': '',\n   'created': 1679017426758,\n   'content': {'id': 'aa36e421-8571-4f0c-b50b-c95146d5cc17',\n    'domain': 'domo-dojo.domo.com',\n    'customerId': '',\n    'userId': '1430590895',\n    'domoObjectId': 'ee24d234-303e-46aa-b062-9905dc0d8622',\n    'type': 'DATASET',\n    'updated': 1679017426758,\n    'hash': '319d8cb7-b450-4de1-bf84-6a6aa31cd9cc'},\n   'isV2': True,\n   'hasDuplicate': False,\n   'useDirectContent': True,\n   'type': 'CONTENT',\n   'isBackup': False,\n   'children': [],\n   'subscriptionAuthorizations': [],\n   'subscribers': []},\n  {'id': 'b9683bc2-33cc-4b10-8b31-9e394da85655',\n   'customerId': '',\n   'created': 1679017426758,\n   'content': {'id': 'dac91f54-6a01-4586-968f-f94b1f4f5aac',\n    'domain': 'domo-dojo.domo.com',\n    'customerId': '',\n    'userId': '1430590895',\n    'domoObjectId': 'ea859b06-5dbe-4c31-be76-de921447d550',\n    'type': 'DATASET',\n    'updated': 1679017426758,\n    'hash': 'd91a8103-723a-4fa1-81be-0ea1e965a2b7'},\n   'isV2': True,\n   'hasDuplicate': False,\n   'useDirectContent': True,\n   'type': 'CONTENT',\n   'isBackup': False,\n   'children': [],\n   'subscriptionAuthorizations': [],\n   'subscribers': []}],\n 'subscriptionAuthorizations': [{'id': 'e1296172-c731-49d3-b543-b5c098cf5f8d',\n   'domain': 'modocorp-admin.domo.com',\n   'created': 1665674091178,\n   'publicationId': '431005fd-ec85-41fe-88f6-7b888222aec2'}],\n 'subscribers': []}\n\n\n\n# #| export\n# def generate_publish_body(url: str, sub_domain_ls: [str], content_ls: [str], name: str, description: str, unique_id: str, is_new: bool):\n#     if not sub_domain_ls:\n#         sub_domain_ls = []\n\n#     if not content_ls:\n#         content_ls = []\n\n#     body = {\n#         \"id\": unique_id,\n#         \"name\": name,\n#         \"description\": description,\n#         \"domain\": url,\n#         \"content\": content_ls,\n#         \"subscriberDomain\": sub_domain_ls,\n#         \"new\": str(is_new).lower()\n#     }\n\n#     return body\n\n# # Creating publish job for a specific subscriber\n\n\n# #| export\n# async def create_publish_job(auth: dmda.DomoAuth, body : dict, session: httpx.AsyncClient = None, debug_api: bool = False) -> rgd.ResponseGetData:\n#     url = f'https://{auth.domo_instance}.domo.com/api/publish/v2/publication'\n\n#     print (body)\n#     res = await get_data(auth=auth,\n#                          method='POST',\n#                          url=url,\n#                          body=body,\n#                          session=session,\n#                          debug_api=debug_api)\n\n#     return res\n\n# # Updating existing publish job with content\n\n\n# #| export\n# async def udpate_publish_job(auth: dmda.DomoAuth, publication_id: str, body: dict, session: httpx.AsyncClient = None, debug_api: bool = False) -> rgd.ResponseGetData:\n\n#     url = f'https://{auth.domo_instance}.domo.com/api/publish/v2/publication/{publication_id}'\n\n#     res = await get_data(auth=auth,\n#                          method='PUT',\n#                          url=url,\n#                          body=body,\n#                          session=session,\n#                          debug_api=debug_api)\n#     return res\n\n# # finds all jobs waiting to be accepted within the subscriber\n\n\n\n\nSubscriptions\n\nsource\n\nget_subscription_summaries\n\n get_subscription_summaries (auth:domolibrary.client.DomoAuth.DomoAuth,\n                             session:httpx.AsyncClient=None,\n                             debug_api:bool=False)\n\nretrieves a summary of existing subscriptions\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await get_subscription_summaries(auth=token_auth)\n\npd.DataFrame(res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      subscriptionId\n      publicationId\n      publisherDomain\n      publicationSummary\n      status\n      result\n      description\n      datasets\n      pages\n      cards\n      created\n      updated\n    \n  \n  \n    \n      0\n      a825f210-77cf-4313-a73d-4d2ae7cd3397\n      c7119a3e-f97d-4221-83c6-56ddd38073b0\n      datamavenllc-io.domo.com\n      {'id': 'c7119a3e-f97d-4221-83c6-56ddd38073b0',...\n      READY\n      SUCCESS\n      Success.\n      4\n      2\n      42\n      1674166687000\n      1674166687000\n    \n    \n      1\n      3436f012-d9ff-4903-835e-3b88dcce11c9\n      d81b0a9a-e6f6-4ca0-b170-c57f91e75c22\n      datamavenllc-io.domo.com\n      {'id': 'd81b0a9a-e6f6-4ca0-b170-c57f91e75c22',...\n      READY\n      MISSING_PAGE\n      Missing page for content id, 465577116. Missin...\n      8\n      3\n      42\n      1645671430000\n      1674168501000\n    \n  \n\n\n\n\n\nsource\n\n\nget_subscription_invititations\n\n get_subscription_invititations\n                                 (auth:domolibrary.client.DomoAuth.DomoAut\n                                 h, session:httpx.AsyncClient=None,\n                                 debug_api:bool=False)\n\nretrieves a list of subscription invitations\n\nsample implementation of get_subscription_invitations\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await get_subscription_invititations(auth=token_auth)\n\npd.DataFrame(res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      publisherDomain\n      publicationSummary\n      status\n    \n  \n  \n    \n      0\n      datamavenllc-io.domo.com\n      {'id': '0f576510-f489-49a5-a2d0-d416221934ca',...\n      READY\n    \n    \n      1\n      datamavenllc-io.domo.com\n      {'id': '6c0c8f80-5eda-4eef-8267-6875ccd596fb',...\n      READY\n    \n  \n\n\n\n\n\nsource\n\n\n\naccept_invite_by_id\n\n accept_invite_by_id (auth:domolibrary.client.DomoAuth.DomoAuth,\n                      subscription_id:str, session:httpx.AsyncClient=None,\n                      debug_api:bool=False)\n\nthis takes get_subscription_invites_list into account and accepts - not instant\n\nsource\n\n\nrefresh_publish_jobs\n\n refresh_publish_jobs (auth:domolibrary.client.DomoAuth.DomoAuth,\n                       publish_ids:list, session:httpx.AsyncClient=None,\n                       debug_api:bool=False)\n\nRefreshing list of publish jobs. Typically “instance” = publisher instance"
  },
  {
    "objectID": "routes/dataflow.html",
    "href": "routes/dataflow.html",
    "title": "Dataflow Routes",
    "section": "",
    "text": "source\n\nget_dataflow_by_id\n\n get_dataflow_by_id (dataflow_id:int,\n                     auth:domolibrary.client.DomoAuth.DomoAuth,\n                     debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nSample implementation of get_dataflow_by_id\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await get_dataflow_by_id(dataflow_id=70, auth=token_auth)\n\nres.response.keys()\n\nfrom pprint import pprint\n\nall_keys = []\nfor action in res.response.get(\"actions\"):\n    pprint(action)\n\nlist(set(all_keys))\n\n{'dataSourceId': '241025d7-3cca-4369-b7c0-b3264277c0e1',\n 'executeFlowWhenUpdated': False,\n 'gui': {'color': None, 'colorSource': None, 'x': None, 'y': None},\n 'id': '241025d7-3cca-4369-b7c0-b3264277c0e1',\n 'onlyLoadNewVersions': False,\n 'pseudoDataSource': False,\n 'targetTableName': 'domostats_people',\n 'truncateRows': False,\n 'truncateTextColumns': False,\n 'type': 'LoadFromVault'}\n{'dependsOn': ['241025d7-3cca-4369-b7c0-b3264277c0e1'],\n 'gui': {'color': None, 'colorSource': None, 'x': None, 'y': None},\n 'id': 'c176aa53-122a-4a2e-8b6f-41ca4a72d67c',\n 'selectStatement': 'SELECT\\n'\n                    '`Display Name`,\\n'\n                    '`User ID`\\n'\n                    ', @row := @row+1 as id\\n'\n                    ', @isReset := case when @iter = @rowCounter then 1 else 0 '\n                    'end isReset\\n'\n                    ', @group := @isReset + @group   as rowGroup\\n'\n                    ', @iter := case when @isReset = 1 then 1 else @iter + 1 '\n                    'end iter\\n'\n                    ', @rowCounter := case when @isReset = 1 then FLOOR( '\n                    'RAND() * (7-3) + 3) else @rowCounter end numChildren\\n'\n                    '\\n'\n                    '\\n'\n                    'from `domostats_people` p\\n'\n                    '\\n'\n                    ', (select @row:= 0,@rowCounter:= 1, @iter := 1, @isReset '\n                    ':= 0 , @group := 0) r',\n 'tableName': 't_1',\n 'type': 'GenerateTableAction'}\n{'dependsOn': ['c176aa53-122a-4a2e-8b6f-41ca4a72d67c'],\n 'gui': {'color': None, 'colorSource': None, 'x': None, 'y': None},\n 'id': 'ac9f630d-d865-4925-b955-4316e227229a',\n 'selectStatement': '\\n'\n                    \"select  b.`User ID` as userID , 'reportsTo' as Action , \"\n                    'a.`User ID` as bodyID\\n'\n                    '\\n'\n                    'from t_1 a \\n'\n                    '\\n'\n                    'join t_1 b \\n'\n                    '\\n'\n                    'on a.id = b.`rowGroup`\\n'\n                    'where a.`User ID` <> b.`User ID`\\n'\n                    '\\n'\n                    'UNION\\n'\n                    '\\n'\n                    \"select  b.`User ID` as userID , 'directReports' as Action \"\n                    ', a.`User ID` as bodyID\\n'\n                    '\\n'\n                    'from t_1 a \\n'\n                    '\\n'\n                    'join t_1 b \\n'\n                    '\\n'\n                    'on b.id = a.`rowGroup`\\n'\n                    '\\n'\n                    'where a.`User ID` <> b.`User ID`\\n'\n                    '\\n',\n 'tableName': 'reportsto',\n 'type': 'GenerateTableAction'}\n{'dataSource': {'guid': 'd9257748-c181-496e-8f9a-016ee99b4a14',\n                'name': 'domoStats_people_reports',\n                'type': 'DataFlow'},\n 'dependsOn': ['ac9f630d-d865-4925-b955-4316e227229a'],\n 'gui': {'color': None, 'colorSource': None, 'x': None, 'y': None},\n 'id': '8edc3d78-3586-47a8-9775-c7b146a50d19',\n 'partitioned': False,\n 'query': 'select * from `reportsto`',\n 'schemaSource': 'DATAFLOW',\n 'type': 'PublishToVault',\n 'versionChainType': 'REPLACE'}\n\n\n[]"
  },
  {
    "objectID": "routes/account.html",
    "href": "routes/account.html",
    "title": "Account Routes",
    "section": "",
    "text": "source\n\nget_accounts\n\n get_accounts (auth:domolibrary.client.DomoAuth.DomoAuth,\n               debug_api:bool=False,\n               session:Optional[httpx.AsyncClient]=None)\n\nretrieve a list of all the accounts the user has read access to. Note users with “Manage all accounts” will retrieve all account objects\n\nsample implementation of get_accounts\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\n\nres = await get_accounts(auth = token_auth)\npd.DataFrame(res.response)\n\n\n\n\n\n  \n    \n      \n      id\n      userId\n      name\n      displayName\n      type\n      valid\n      dataProviderType\n      credentialsType\n      createdAt\n      createdBy\n      modifiedAt\n      modifiedBy\n      configurations\n      accountTemplateId\n      accountTemplateAuthorizationId\n      accountId\n    \n  \n  \n    \n      0\n      1\n      1893952720\n      DataSet Copy Account\n      DataSet Copy Account\n      data\n      True\n      dataset-copy\n      fields\n      1589100087000\n      1893952720\n      1589100087000\n      1893952720\n      {}\n      None\n      None\n      1\n    \n    \n      1\n      5\n      1893952720\n      Domo Governance Datasets Third Party Account\n      test_rename\n      data\n      True\n      domo-governance-d14c2fef-49a8-4898-8ddd-f64998...\n      fields\n      1616777681000\n      1893952720\n      1679017407000\n      1893952720\n      {}\n      None\n      None\n      5\n    \n    \n      2\n      27\n      1893952720\n      DataSet Copy Account\n      DataSet Copy Account\n      data\n      True\n      domo-csv\n      fields\n      1619083568000\n      1893952720\n      1619083568000\n      1893952720\n      {}\n      None\n      None\n      27\n    \n    \n      3\n      45\n      1893952720\n      onyxReporting@gmail.com\n      onyxReporting@gmail.com\n      data\n      True\n      google-spreadsheets\n      oauth\n      1664924354000\n      1893952720\n      1664924354000\n      1893952720\n      {}\n      None\n      None\n      45\n    \n  \n\n\n\n\n\nsource\n\n\n\nget_account_from_id\n\n get_account_from_id (auth:domolibrary.client.DomoAuth.DomoAuth,\n                      account_id:int, debug_api:bool=False,\n                      session:httpx.AsyncClient=None)\n\nretrieves metadata about an account\n\nsource\n\n\nGetAccount_NoMatch\n\n GetAccount_NoMatch (account_id, domo_instance, status,\n                     function_name='get_account_from_id')\n\nbase exception\n\nsample implementation of get_account_from_id\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\ntry:\n    res = await get_account_from_id(auth=token_auth, account_id = 152)\n    res.response\nexcept GetAccount_NoMatch as e:\n    print(e)\n\nget_account_from_id: Status 403 - account_id 152 not found at domo-dojo\n\n\n\n\n\nAccount Config\n\nsource\n\nget_account_config\n\n get_account_config (auth:domolibrary.client.DomoAuth.DomoAuth,\n                     account_id:int, data_provider_type:str,\n                     debug_api:bool=False,\n                     session:Optional[httpx.AsyncClient]=None)\n\n\nsource\n\n\nAccountConfig_InvalidDataProvider\n\n AccountConfig_InvalidDataProvider (account_id:str,\n                                    data_provider_type:str,\n                                    domo_instance:str)\n\nCommon base class for all non-exit exceptions.\n\nsample implementation of get_account_config\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await get_account_config(auth=token_auth, account_id=1, data_provider_type='dataset-copy')\nres.response\n\n{'instance': 'northshore-io-partner.domo.com', 'accessToken': '********'}\n\n\n\nsource\n\n\n\nupdate_account_config\n\n update_account_config (auth:domolibrary.client.DomoAuth.DomoAuth,\n                        account_id:int, config_body:dict,\n                        data_provider_type:str, debug_api:bool=False,\n                        session:httpx.AsyncClient=None)\n\n\nsource\n\n\nupdate_account_name\n\n update_account_name (auth:domolibrary.client.DomoAuth.DomoAuth,\n                      account_id:int, account_name:str,\n                      debug_api:bool=False,\n                      session:httpx.AsyncClient=None)\n\n\nsource\n\n\ncreate_account\n\n create_account (auth:domolibrary.client.DomoAuth.DomoAuth,\n                 config_body:dict, debug_api:bool=False,\n                 session:httpx.AsyncClient=None)\n\n\nsource\n\n\ndelete_account\n\n delete_account (auth:domolibrary.client.DomoAuth.DomoAuth,\n                 account_id:str, debug_api:bool=False,\n                 session:httpx.AsyncClient=None)\n\n\n\n\nAccount Sharing\n\nsource\n\ngenerate_share_account_payload_v2\n\n generate_share_account_payload_v2 (user_id:int, access_level:str)\n\n\nsource\n\n\ngenerate_share_account_payload_v1\n\n generate_share_account_payload_v1 (user_id:int, access_level:str)\n\n\nsource\n\n\nShareAccount_V2_AccessLevel\n\n ShareAccount_V2_AccessLevel (value, names=None, module=None,\n                              qualname=None, type=None, start=1)\n\nAn enumeration.\n\nsource\n\n\nShareAccount_V1_AccessLevel\n\n ShareAccount_V1_AccessLevel (value, names=None, module=None,\n                              qualname=None, type=None, start=1)\n\nAn enumeration.\n\ngenerate_share_account_payload_v2(1, 'CAN_VIEW')\n\n{'type': 'USER', 'id': 1, 'accessLevel': 'CAN_VIEW'}\n\n\n\nsource\n\n\nshare_account_v1\n\n share_account_v1 (auth:domolibrary.client.DomoAuth.DomoAuth,\n                   account_id:str, share_payload:dict,\n                   debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nsource\n\n\nshare_account_v2\n\n share_account_v2 (auth:domolibrary.client.DomoAuth.DomoAuth,\n                   account_id:str, share_payload:dict,\n                   debug_api:bool=False, session:httpx.AsyncClient=None)"
  },
  {
    "objectID": "routes/role.html",
    "href": "routes/role.html",
    "title": "Role Routes",
    "section": "",
    "text": "Get and Search Routes\n\nsource\n\nRole_NotRetrieved\n\n Role_NotRetrieved (domo_instance, function_name, status, message,\n                    role_id=None)\n\nbase exception\n\nsource\n\n\nget_roles\n\n get_roles (auth:domolibrary.client.DomoAuth.DomoAuth,\n            debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nsample implementation of get_roles\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await get_roles(auth=token_auth)\n\npd.DataFrame(res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      id\n      name\n      description\n      authorityCount\n      userCount\n      created\n      modified\n    \n  \n  \n    \n      0\n      1\n      Admin\n      Full access to everything\n      77\n      16\n      1580425515000\n      1580425515000\n    \n    \n      1\n      2\n      Privileged\n      Full access except for editing users and setti...\n      34\n      310\n      1580425515000\n      1580425515000\n    \n    \n      2\n      3\n      Editor\n      Can edit Cards, Pages, DataSets, and Dataflows\n      30\n      3\n      1580425515000\n      1580425515000\n    \n    \n      3\n      4\n      Participant\n      Read only access on Cards, Pages DataSets and ...\n      6\n      4\n      1580425515000\n      1580425515000\n    \n    \n      4\n      5\n      Social\n      Access limited to social features\n      1\n      11\n      1580425515000\n      1580425515000\n    \n  \n\n\n\n\n\nsource\n\n\n\nget_role_grants\n\n get_role_grants (auth:domolibrary.client.DomoAuth.DomoAuth, role_id:str,\n                  debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nsample implementation of get_role_grants\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await get_role_grants(auth=token_auth, role_id = 1)\n\npd.DataFrame(res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      0\n      versions.deployment.manage\n    \n    \n      1\n      buzz.admin\n    \n    \n      2\n      dataflow.admin\n    \n    \n      3\n      goal.admin\n    \n    \n      4\n      dataset.admin\n    \n  \n\n\n\n\n\nsource\n\n\n\nget_role_membership\n\n get_role_membership (auth:domolibrary.client.DomoAuth.DomoAuth,\n                      role_id:str, debug_api:bool=False,\n                      session:httpx.AsyncClient=None,\n                      return_raw:bool=False)\n\n\nsample implementation of get_role_membership\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nres = await get_role_membership(auth=token_auth, role_id=1, return_raw = False)\n\npd.DataFrame(res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      userId\n      email\n      displayName\n      roleId\n      department\n      jobTitle\n      hireDate\n      location\n      timeZone\n    \n  \n  \n    \n      0\n      1345408759\n      DataMaven42@gmail.com\n      Alexis Lorenz (DataMaven)\n      1\n      Owner\n      Major Domo Support Specialist\n      1.590156e+12\n      NaN\n      NaN\n    \n    \n      1\n      1102391116\n      andrea.henderson@domo.com\n      Andrea Henderson\n      1\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      2\n      1095515127\n      andrew@crystalballers.ai\n      Andrew Chaffin\n      1\n      Crystal Ballers\n      Cofounder\n      NaN\n      \n      NaN\n    \n    \n      3\n      2074422502\n      bard.higgins@gmail.com\n      Bard Higgins\n      1\n      NaN\n      NaN\n      NaN\n      NaN\n      America/Denver\n    \n    \n      4\n      1865099622\n      Ben.Schein@domo.com\n      Ben Schein\n      1\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n  \n\n\n\n\n\n\n\n\nCRUD Routes\n\nsource\n\ncreate_role\n\n create_role (auth:domolibrary.client.DomoAuth.DomoAuth, name:str,\n              description:str, debug_api:bool=False,\n              session:httpx.AsyncClient=None)\n\n\nsource\n\n\ndelete_role\n\n delete_role (auth:domolibrary.client.DomoAuth.DomoAuth, role_id:int,\n              debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nsample implementation of delete_role\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nawait delete_role(auth=token_auth, role_id='2014090557')\n\nResponseGetData(status=204, response=\"role 2014090557 deleted or doesn't exist\", is_success=True)\n\n\n\nsource\n\n\n\nset_default_role\n\n set_default_role (auth:domolibrary.client.DomoAuth.DomoAuth, role_id:str,\n                   debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nsource\n\n\nupdate_role_metadata\n\n update_role_metadata (auth:domolibrary.client.DomoAuth.DomoAuth, role_id,\n                       role_name, role_description:str=None,\n                       debug_api:bool=False,\n                       session:httpx.AsyncClient=None)\n\n\nsample update_role_metadata\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\n#get role to update\nrole_ls = await get_roles(auth = token_auth)\nrole = next((role for role in role_ls.response if role.get('name') == 'super_admin'),None)\n\n\n# update role\nawait update_role_metadata(auth=token_auth,\n                     role_id = role['id'],\n                     role_name= role['name'],\n                           role_description=f'last updated - {dt.date.today()}'\n                     )\n\n# validate role has been updated\nrole_ls = await get_roles(auth=token_auth)\nrole = next((role for role in role_ls.response if role.get(\n    'name') == 'super_admin'), None)\n\nrole\n\n{'id': 810756122,\n 'name': 'super_admin',\n 'description': 'last updated - 2023-03-17',\n 'authorityCount': 84,\n 'userCount': 1,\n 'created': 1678842530000,\n 'modified': 1679017430000}\n\n\n\nsource\n\n\n\nset_role_grants\n\n set_role_grants (auth:domolibrary.client.DomoAuth.DomoAuth, role_id:str,\n                  role_grant_ls:list[str], debug_api:bool=False)\n\n\nsource\n\n\nrole_membership_add_users\n\n role_membership_add_users (auth:domolibrary.client.DomoAuth.DomoAuth,\n                            role_id:str, user_list:list[str],\n                            debug_api:bool=False,\n                            session:httpx.AsyncClient=None)"
  },
  {
    "objectID": "routes/bootstrap.html",
    "href": "routes/bootstrap.html",
    "title": "Bootstrap Routes",
    "section": "",
    "text": "Bootstrap Routes\n\nsource\n\nget_bootstrap\n\n get_bootstrap (auth:domolibrary.client.DomoAuth.DomoFullAuth,\n                debug_api:bool=False, session:httpx.AsyncClient=None)\n\nget bootstrap data\n\nsample implementation of get_boostrap\n\nimport os\n\n\nauth = dmda.DomoTokenAuth(\n    domo_instance='domo-dojo', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\n# auth = dmda.DomoFullAuth(\n#     domo_instance='domo-dojo', domo_password = os.environ['DOJO_PASSWORD'], domo_username = 'jae@onyxreporting.com')\n\ntry:\n    await get_bootstrap(auth = auth, debug_api = False)\n    \nexcept dmda.InvalidAuthTypeError as e:\n    print(e)\n\nget_bootstrap: This API rquires DomoFullAuth at domo-dojo\n\n\n\nimport os\n\nfull_auth = dmda.DomoFullAuth(\n    domo_instance='domo-dojo', domo_password = os.environ['DOJO_PASSWORD'], domo_username = 'jae@onyxreporting.com')\n\nres = await get_bootstrap(auth = full_auth, debug_api = False)\nres.response.keys()\n\ndict_keys(['notifierConfig', 'currentUser', 'data'])\n\n\n\nsource\n\n\n\nget_bootstrap_features\n\n get_bootstrap_features (auth:domolibrary.client.DomoAuth.DomoAuth,\n                         session:httpx.AsyncClient=None,\n                         debug_api:bool=False)\n\n\nsample implementation of get_bootstrap_features\n\nimport os\nimport pandas as pd\n\nfull_auth = dmda.DomoFullAuth(\n    domo_instance='domo-dojo', domo_password=os.environ['DOJO_PASSWORD'], domo_username='jae@onyxreporting.com')\n\nres = await get_bootstrap_features(auth=full_auth, debug_api=False)\n\npd.DataFrame(res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      id\n      name\n      label\n      description\n      enabled\n      purchased\n      type\n      environment\n      owner\n    \n  \n  \n    \n      0\n      4\n      search\n      \n      \n      True\n      False\n      STANDARD\n      \n      \n    \n    \n      1\n      5\n      launcher\n      \n      \n      True\n      True\n      PREMIUM\n      \n      \n    \n    \n      2\n      9\n      profile-reminder\n      \n      \n      True\n      False\n      STANDARD\n      \n      \n    \n    \n      3\n      17\n      enableSwapDatasource\n      \n      \n      True\n      False\n      STANDARD\n      \n      \n    \n    \n      4\n      19\n      up\n      \n      \n      True\n      True\n      STANDARD\n      \n      \n    \n  \n\n\n\n\n\nsource\n\n\n\nget_bootstrap_pages\n\n get_bootstrap_pages (auth:domolibrary.client.DomoAuth.DomoAuth,\n                      session:httpx.AsyncClient=None,\n                      debug_api:bool=False)\n\n\nsample get bootstrap pages\n\nimport os\nimport pandas as pd\n\nfull_auth = dmda.DomoFullAuth(\n    domo_instance='domo-dojo', domo_password=os.environ['DOJO_PASSWORD'], domo_username='jae@onyxreporting.com')\n\nres = await get_bootstrap_pages(auth=full_auth, debug_api=False)\n\npd.DataFrame(res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      id\n      title\n      locked\n      sharedView\n      pageVisible\n      owner\n      virtualPage\n      isValidBadgePage\n      canAddCard\n      bibHiddenPage\n      hasAccess\n      hierarchy\n      separator\n      type\n      pageLocation\n      owners\n      isOwner\n      childCount\n      children\n    \n  \n  \n    \n      0\n      -100000\n      Overview\n      False\n      False\n      True\n      0\n      True\n      True\n      True\n      False\n      True\n      0\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      -100003\n      Favorites\n      False\n      False\n      True\n      0\n      True\n      NaN\n      False\n      False\n      True\n      0\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      2\n      -100002\n      Shared\n      False\n      False\n      True\n      0\n      True\n      NaN\n      False\n      False\n      True\n      0\n      True\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      3\n      30507758\n      Welcome\n      True\n      True\n      True\n      587894148\n      NaN\n      NaN\n      True\n      False\n      True\n      0\n      NaN\n      page\n      0.0\n      [{'id': 1814479647, 'type': 'GROUP', 'displayN...\n      False\n      0.0\n      NaN\n    \n    \n      4\n      1267639476\n      Dojo Solutions\n      True\n      True\n      True\n      587894148\n      NaN\n      NaN\n      True\n      False\n      True\n      0\n      NaN\n      page\n      1.0\n      [{'id': 587894148, 'type': 'USER', 'displayNam...\n      False\n      3.0\n      [{'id': '1759878295', 'title': 'Beast Modes', ..."
  },
  {
    "objectID": "routes/datacenter.html",
    "href": "routes/datacenter.html",
    "title": "Datacenter Routes",
    "section": "",
    "text": "source\n\nDataflow_Type_Filter_Enum\n\n Dataflow_Type_Filter_Enum (value, names=None, module=None, qualname=None,\n                            type=None, start=1)\n\nAn enumeration.\n\nsource\n\n\nDatacenter_Enum\n\n Datacenter_Enum (value, names=None, module=None, qualname=None,\n                  type=None, start=1)\n\nAn enumeration.\n\nsource\n\n\ngenerate_search_datacenter_body\n\n generate_search_datacenter_body (entities_list:list[str]=None,\n                                  filters:list[dict]=None,\n                                  combineResults:bool=True, count:int=10,\n                                  offset:int=0)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nentities_list\nlist\nNone\ndefaults to Dataset\n\n\nfilters\nlist\nNone\n\n\n\ncombineResults\nbool\nTrue\n\n\n\ncount\nint\n10\n\n\n\noffset\nint\n0\n\n\n\n\n\nsource\n\n\ngenerate_search_datacenter_account_body\n\n generate_search_datacenter_account_body (search_str:str,\n                                          is_exact_match:bool=True)\n\n\nsource\n\n\nsearch_datacenter\n\n search_datacenter (auth:domolibrary.client.DomoAuth.DomoAuth,\n                    loop_until_end:bool=True, maximum:int=None,\n                    body:dict=None, entity_ls:list[str]=None,\n                    arr_fn:<built-infunctioncallable>=None, limit=100,\n                    session:httpx.AsyncClient=None, debug_api:bool=False)\n\n\nsample implementation of generate_search body and search datacenter\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nbody = generate_search_datacenter_body(\n    entities_list=[Datacenter_Enum.DATAFLOW.value],\n    filters=[Dataflow_Type_Filter_Enum.MAGICV2.value],\n)\n\nres = await search_datacenter(auth=token_auth, body=body)\n\npd.DataFrame(res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      entityType\n      databaseId\n      searchId\n      createDate\n      lastModified\n      lastIndexed\n      highlightedFields\n      language\n      requestAccess\n      score\n      name\n      description\n      ownedById\n      ownedByName\n      tags\n      lastRunDate\n      inputDatasets\n      outputDatasets\n      runCount\n      successRate\n      dataFlowType\n      status\n      lastExecutionError\n      deleted\n      passwordProtected\n      abandoned\n      owners\n      ownersLocalized\n      paused\n      statusOrderPriority\n      inputCount\n      outputCount\n      winnerText\n      ownedByType\n      customer\n    \n  \n  \n    \n      0\n      dataflow\n      129\n      {'indexName': None, 'databaseId': '129', 'cust...\n      1678081723000\n      1678726307000\n      1678988125418\n      {}\n      English\n      False\n      62.424180\n      GR_DS_OP ETL\n      \n      1345737456\n      Aditya Jain\n      []\n      1678988002000\n      [{'name': 'GR', 'id': '1883b888-e3b5-4998-9c5a...\n      [{'name': 'GR_DS_OP', 'id': 'f17268f8-5e1d-422...\n      19\n      0.789474\n      MAGIC\n      FAILED\n      {'code': 'DP-0001', 'localizedMessage': 'Colum...\n      False\n      False\n      False\n      [{'id': '1345737456', 'type': 'USER', 'display...\n      {'localizedMessage': 'Aditya Jain', 'count': 1}\n      False\n      10\n      2\n      1\n      GR_DS_OP ETL\n      USER\n      mmmm-0012-0200\n    \n    \n      1\n      dataflow\n      131\n      {'indexName': None, 'databaseId': '131', 'cust...\n      1678147044000\n      1678147835000\n      1678148793623\n      {}\n      English\n      False\n      10.000001\n      BeastModesGovernance_01_AccumulateHistory\n      \n      1893952720\n      Jae Wilson\n      []\n      1678147669000\n      [{'name': 'Governance_Beast Modes', 'id': 'b79...\n      [{'name': 'Governance_BeastMode_historical', '...\n      2\n      1.000000\n      MAGIC\n      SUCCESS\n      NaN\n      False\n      False\n      False\n      [{'id': '1893952720', 'type': 'USER', 'display...\n      {'localizedMessage': 'Jae Wilson', 'count': 1}\n      False\n      70\n      1\n      1\n      BeastModesGovernance_01_AccumulateHistory\n      USER\n      mmmm-0012-0200\n    \n    \n      2\n      dataflow\n      37\n      {'indexName': None, 'databaseId': '37', 'custo...\n      1619005428000\n      1619007232000\n      1619080673093\n      {}\n      English\n      False\n      10.000001\n      EX01_FuzzyMatch_Master\n      \n      1893952720\n      Jae Wilson\n      []\n      1619007232000\n      [{'name': 'EX01_Expedia_Room Types', 'id': '5c...\n      [{'name': 'EX01_FuzzyMatch_Master', 'id': '53a...\n      2\n      1.000000\n      MAGIC\n      SUCCESS\n      NaN\n      False\n      False\n      False\n      [{'id': '1893952720', 'type': 'USER', 'display...\n      {'localizedMessage': 'Jae Wilson', 'count': 1}\n      False\n      70\n      2\n      1\n      EX01_FuzzyMatch_Master\n      USER\n      mmmm-0012-0200\n    \n    \n      3\n      dataflow\n      38\n      {'indexName': None, 'databaseId': '38', 'custo...\n      1619005563000\n      1619077579000\n      1619080673093\n      {}\n      English\n      False\n      10.000001\n      EX01_FuzzyMatch_Master_RECURSIVE\n      \n      1893952720\n      Jae Wilson\n      []\n      1619007065000\n      [{'name': 'EX01_Expedia_Room Types', 'id': '5c...\n      [{'name': 'EX01_FuzzyMatch_Master_RECURSIVE', ...\n      3\n      1.000000\n      MAGIC\n      SUCCESS\n      NaN\n      False\n      False\n      False\n      [{'id': '1893952720', 'type': 'USER', 'display...\n      {'localizedMessage': 'Jae Wilson', 'count': 1}\n      False\n      70\n      3\n      1\n      EX01_FuzzyMatch_Master_RECURSIVE\n      USER\n      mmmm-0012-0200\n    \n    \n      4\n      dataflow\n      124\n      {'indexName': None, 'databaseId': '124', 'cust...\n      1675787096000\n      1675787978000\n      1675789364742\n      {}\n      English\n      False\n      10.000001\n      Recursive+Partition_Demo\n      \n      1893952720\n      Jae Wilson\n      []\n      1675787722000\n      [{'name': 'Fun Sample_Baby Names_States', 'id'...\n      [{'name': 'Recursive+Partition', 'id': 'e08f1f...\n      3\n      1.000000\n      MAGIC\n      SUCCESS\n      NaN\n      False\n      False\n      False\n      [{'id': '1893952720', 'type': 'USER', 'display...\n      {'localizedMessage': 'Jae Wilson', 'count': 1}\n      False\n      70\n      1\n      1\n      Recursive+Partition_Demo\n      USER\n      mmmm-0012-0200\n    \n  \n\n\n\n\n\nsource\n\n\n\nget_lineage_upstream\n\n get_lineage_upstream (auth:domolibrary.client.DomoAuth.DomoAuth,\n                       entity_type:str, entity_id:str,\n                       session:httpx.AsyncClient=None,\n                       debug_api:bool=False)\n\n\nimport os\n# import pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance='domo-dojo',\n    domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\nres = await get_lineage_upstream(auth=token_auth,\n                                 entity_type = Datacenter_Enum.DATAFLOW.value,\n                                 entity_id=4\n\n                                 )\n\npd.DataFrame([ obj for obj in res.response.values()])\n\n\n\n\n\n  \n    \n      \n      type\n      id\n      descendantCounts\n      ancestorCounts\n      complete\n      children\n      parents\n    \n  \n  \n    \n      0\n      DATA_SOURCE\n      45a7a24e-c738-44f9-9019-00d5a33613ae\n      {}\n      {'DATAFLOW': 2, 'DATA_SOURCE': 2}\n      True\n      [{'type': 'DATAFLOW', 'id': '4', 'complete': T...\n      [{'type': 'DATAFLOW', 'id': '3', 'complete': T...\n    \n    \n      1\n      DATAFLOW\n      4\n      {}\n      {'DATAFLOW': 2, 'DATA_SOURCE': 3}\n      True\n      []\n      [{'type': 'DATA_SOURCE', 'id': '45a7a24e-c738-...\n    \n    \n      2\n      DATAFLOW\n      2\n      {}\n      {'DATA_SOURCE': 1}\n      True\n      [{'type': 'DATA_SOURCE', 'id': '0647a9ed-1a8e-...\n      [{'type': 'DATA_SOURCE', 'id': '241025d7-3cca-...\n    \n    \n      3\n      DATA_SOURCE\n      0647a9ed-1a8e-420e-bd66-34f313a18595\n      {}\n      {'DATAFLOW': 1, 'DATA_SOURCE': 1}\n      True\n      [{'type': 'DATAFLOW', 'id': '3', 'complete': T...\n      [{'type': 'DATAFLOW', 'id': '2', 'complete': T...\n    \n    \n      4\n      DATAFLOW\n      3\n      {}\n      {'DATAFLOW': 1, 'DATA_SOURCE': 2}\n      True\n      [{'type': 'DATA_SOURCE', 'id': '45a7a24e-c738-...\n      [{'type': 'DATA_SOURCE', 'id': '0647a9ed-1a8e-...\n    \n    \n      5\n      DATA_SOURCE\n      241025d7-3cca-4369-b7c0-b3264277c0e1\n      {}\n      {}\n      True\n      [{'type': 'DATAFLOW', 'id': '2', 'complete': T...\n      []"
  },
  {
    "objectID": "routes/grant.html",
    "href": "routes/grant.html",
    "title": "Grant Routes",
    "section": "",
    "text": "source\n\nGetGrants_Error\n\n GetGrants_Error (status, message, domo_instance, function_name)\n\nbase exception\n\nsource\n\n\nget_grants\n\n get_grants (auth:domolibrary.client.DomoAuth.DomoAuth,\n             debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nsample implementation of get_grants\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\nres = await get_grants(auth=token_auth)\n\npd.DataFrame(res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      authority\n      title\n      description\n      authorityUIGroup\n      userCount\n      roleIds\n      dependsOnAuthorities\n      systemGroup\n    \n  \n  \n    \n      0\n      authorization.roles\n      Manage all roles\n      Create, edit and delete custom roles. Assign a...\n      COMPANY\n      17\n      [1, 275763436, 810756122]\n      [ui.admin]\n      True\n    \n    \n      1\n      audit\n      View activity logs\n      View and export audit logs.\n      COMPANY\n      118\n      [1, 275763436, 810756122, 1927158482, 15631017...\n      [ui.admin]\n      True\n    \n    \n      2\n      customer.edit\n      Manage all company settings\n      Manage company metadata, authentication rules,...\n      COMPANY\n      17\n      [1, 275763436, 810756122]\n      [ui.admin]\n      True\n    \n    \n      3\n      developer.token.manage\n      Manage all access tokens and API clients\n      Create and delete any access tokens and API cl...\n      COMPANY\n      22\n      [1, 275763436, 810756122, 1927158482]\n      [ui.admin]\n      True\n    \n    \n      4\n      domo.system.messages\n      Receive Domo System Messages\n      Receive Domo system messages about maintenance...\n      COMPANY\n      22\n      [1, 275763436, 810756122, 1927158482]\n      [ui.admin]\n      True"
  },
  {
    "objectID": "routes/activity_log.html",
    "href": "routes/activity_log.html",
    "title": "Activity Log Routes",
    "section": "",
    "text": "source\n\nget_activity_log_object_types\n\n get_activity_log_object_types (auth:domolibrary.client.DomoAuth.DomoAuth)\n\nretrieves a list of valid objectTypes that can be used to search the activity_log API\n\nsample implementation of get_activity_log_object_types\n\nimport os\nimport pandas as pd\n\ntry:\n    token_auth = dmda.DomoTokenAuth(\n        domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n        domo_instance=\"domo-dojo\",\n    )\n\n    al_objecttype_res = await get_activity_log_object_types(auth=token_auth)\n\n    print(pd.DataFrame(al_objecttype_res.response))\n\n    # use to update `ActivityLog_ObjectType` enum\n    # [ f\"{objecttype.get('translation').upper().replace(' ', '_')} = '{objecttype.get('type')}'\" for objecttype in  al_objecttype_res.response]\n\nexcept Exception as e:\n    print(e)\n\n                  type         translation\n0         ACCESS_TOKEN        Access token\n1              ACCOUNT             Account\n2         ACTIVITY_LOG        Activity log\n3                ALERT               Alert\n4                  APP                 App\n..                 ...                 ...\n60                VIEW                View\n61        VIRTUAL_USER        Virtual user\n62     Workbench_AGENT     Workbench agent\n63       Workbench_JOB       Workbench job\n64  Workbench_SCHEDULE  Workbench schedule\n\n[65 rows x 2 columns]\n\n\n\nsource\n\n\n\nsearch_activity_log\n\n search_activity_log (auth:domolibrary.client.DomoAuth.DomoAuth,\n                      start_time:int, end_time:int, maximum:int,\n                      object_type:str=None,\n                      session:httpx.AsyncClient=None,\n                      debug_api:bool=False, debug_loop:bool=False)\n\nloops over activity log api to retrieve audit logs\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nimport domolibrary.utils.convert as convert\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\npage_res = await search_activity_log(\n    object_type= 'PAGE',\n    start_time=convert.convert_datetime_to_epoch_millisecond(start_datetime),\n    end_time=convert.convert_datetime_to_epoch_millisecond(end_datetime),\n    auth=token_auth,\n    maximum=16,\n    debug_loop=False,\n    debug_api = False\n)\n\npd.DataFrame(page_res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      objectId\n      objectName\n    \n  \n  \n    \n      0\n      -100000\n      Overview\n    \n    \n      1\n      -100001\n      Alerts\n    \n    \n      2\n      -100002\n      Shared\n    \n    \n      3\n      -100003\n      Favorites\n    \n    \n      4\n      -100012\n      CEO\n    \n  \n\n\n\n\n\nsample implementation of search_activity_log\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nimport domolibrary.utils.convert as convert\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\nactivity_log_res = await search_activity_log(\n    object_type= 'ACTIVITY_LOG',\n    start_time=convert.convert_datetime_to_epoch_millisecond(start_datetime),\n    end_time=convert.convert_datetime_to_epoch_millisecond(end_datetime),\n    auth=token_auth,\n    maximum=10,\n    debug_loop=False,\n    debug_api=False,\n)\n\npd.DataFrame(activity_log_res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      userName\n      userId\n      userType\n      actorName\n      actorId\n      actionType\n      objectName\n      objectId\n      objectType\n      additionalComment\n      time\n      eventText\n      clientId\n    \n  \n  \n    \n      0\n      Jae Wilson1\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson1 logged in. Logged in from IP addre...\n      1679017432924\n      Logged in\n      None\n    \n    \n      1\n      Jae Wilson1\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      super_admin\n      810756122\n      ROLE\n      Jae Wilson1 updated role super_admin.  Role de...\n      1679017430038\n      Updated role\n      None\n    \n    \n      2\n      Jae Wilson1\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson1 logged in. Logged in from IP addre...\n      1679017429899\n      Logged in\n      None\n    \n    \n      3\n      Jae Wilson1\n      1893952720\n      USER\n      \n      0\n      DELETED\n      ROLE:2014090557\n      2014090557\n      ROLE\n      Jae Wilson1 deleted role ROLE:2014090557.\n      1679017429411\n      Deleted role\n      None\n    \n    \n      4\n      Jae Wilson1\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson1 logged in. Logged in from IP addre...\n      1679017429103\n      Logged in\n      None"
  },
  {
    "objectID": "routes/group.html",
    "href": "routes/group.html",
    "title": "Group Routes",
    "section": "",
    "text": "source\n\ngenerate_body_create_group\n\n generate_body_create_group (group_name:str, group_type:str='open',\n                             description:str='')\n\nGenerates the body to create group for content_v2_group API\n\nsample implementation of generate_body_create_group\n\ngenerate_body_create_group(\n    group_name='test_group_name', \n    group_type='open', \n    description='from jupyter')\n\n{'name': 'test_group_name', 'type': 'open', 'description': 'from jupyter'}\n\n\n\nsource\n\n\n\ncreate_group\n\n create_group (auth:domolibrary.client.DomoAuth.DomoAuth, group_name:str,\n               group_type:str='open', description:str='',\n               debug_api:bool=False, session:httpx.AsyncClient=None)\n\n\nsource\n\n\nCreateGroup_Error\n\n CreateGroup_Error (status, message, domo_instance,\n                    function_name='create_group')\n\nbase exception\n\nSample implementation of create_group\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", \n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\ntry:\n    res = await create_group(auth=token_auth, group_name='Test Group 2', debug_api=False)\n    res.response\n\nexcept CreateGroup_Error as e:\n    print(e)\n\ncreate_group: Status 400 - Bad Request at domo-dojo\n\n\n\n# #| export\n# async def get_all_groups(auth: dmda.DomoAuth,\n#                          log_results: bool = False,\n#                          debug: bool = False,\n#                          session: httpx.AsyncClient = None) -> rgd:\n#     if debug:\n#         print(auth)\n\n#     url = f'https://{auth.domo_instance}.domo.com/api/content/v2/groups/grouplist'\n\n#     if debug:\n#         print(auth, url)\n\n#     if log_results:\n#         print(f'Getting groups from - {url}')\n\n#     res = await gd(url=url, method='GET', auth=auth, session=session)\n\n#     return res\n\n\n# #| export\n# async def search_groups_by_name(auth: DomoFullAuth,\n#                                 search_name: str,\n#                                 debug: bool = False, log_results: bool = False) -> rgd:\n#     url = f'https://{auth.domo_instance}.domo.com/api/content/v2/groups/grouplist?ascending=true&search={search_name}&sort=name '\n\n#     res = await gd(\n#         auth=auth,\n#         url=url,\n#         method='GET',\n#         debug=debug,\n#         log_results=log_results\n#     )\n#     return res\n\n\nsource\n\n\n\ngenerate_body_update_group_membership\n\n generate_body_update_group_membership (group_id:str,\n                                        add_user_arr:list[str]=None,\n                                        remove_user_arr:list[str]=None,\n                                        add_owner_user_arr:list[str]=None,\n                                        remove_owner_user_arr:list[str]=No\n                                        ne)\n\n\n# #| export\n# async def update_group_membership(auth: DomoFullAuth,\n#                                   body: dict,\n#                                   log_results: bool = False, debug: bool = False) -> ResponseGetData:\n#     # body = [{\n#     #     \"groupId\":\"GROUP_ID\",\n#     #     \"removeMembers\": [{\"type\":\"USER\",\"id\":\"USER_ID\"}],\n#     #     \"addMembers\"   : [{\"type\":\"USER\",\"id\":\"USER_ID\"}]\n#     # }]\n\n#     url = f'https://{auth.domo_instance}.domo.com/api/content/v2/groups/access'\n\n#     if debug:\n#         print(url, body)\n\n#     res = await gd(\n#         auth=auth,\n#         url=url,\n#         method='PUT',\n#         body=body,\n#         debug=debug\n#     )\n\n#     return res\n\n\n# #| export\n# async def get_group_by_id(auth:DomoFullAuth, group_id:id, debug:bool = False) -> ResponseGetData:\n#     url = f'https://{auth.domo_instance}.domo.com/api/content/v2/groups/{group_id}'\n\n#     if debug:\n#         print(url)\n\n#     res = await gd(\n#         auth=auth,\n#         url=url,\n#         method='GET',\n#         debug=debug\n#     )\n\n#     return res"
  },
  {
    "objectID": "utils/read_creds_from_dotenv.html",
    "href": "utils/read_creds_from_dotenv.html",
    "title": "Read Creds from DotEnv",
    "section": "",
    "text": "source\n\nread_creds_from_dotenv\n\n read_creds_from_dotenv (env_path:str='.env', params:list[str]=None)\n\nuse_prod = false will replace all PROD values with matching TEST values\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nenv_path\nstr\n.env\n\n\n\nparams\nlist\nNone\nlist of params you’re expecting in the env file,\n\n\nReturns\nDictDot\n\n\n\n\n\n\nsource\n\n\nReadCreds_EnvFileNotExist\n\n ReadCreds_EnvFileNotExist (env_path)\n\nCommon base class for all non-exit exceptions.\n\nsample implementation of read creds\n\n# import json\n\n# TEST_ENV_PATH = '_test_env.txt'\n\n# params = [\"APPLICATION_ID\", \"DATASET_ID\", \"ACCOUNT_ID\", \"SAMPLE_ARRAY\"]\n\n# env = read_creds_from_dotenv(TEST_ENV_PATH, params = params)\n\n# print(env)\n# print(json.loads(env.SAMPLE_ARRAY))\n\n\n# # | export\n# def split_creds(env: utils_dd.DictDot, key_starts_with: str, env_var_list: list[str]):\n#     env_lines_to_split = [getattr(env, key) for key in dir(\n#         env) if key.startswith(key_starts_with)]\n\n#     return [utils_dd.split_str_to_obj(env_string=line, value_split_keys=env_var_list) for line in env_lines_to_split]"
  },
  {
    "objectID": "utils/dictdot.html",
    "href": "utils/dictdot.html",
    "title": "DictDot",
    "section": "",
    "text": "source\n\nDictDot\n\n DictDot (dictionary:dict, **kwargs)\n\na utility class that converts json into an object that supports data retrieval with dot notation\n\n\n\n\nType\nDetails\n\n\n\n\ndictionary\ndict\ndictionary to convert\n\n\nkwargs\n\n\n\n\n\n\nsample implementation of DictDot\n\nfoo = { \"name\": \"my object\", \"description\" : \"please convert me\", \"type\": \"a good old fashioned dictionary\"}\n\ndd = DictDot(foo)\n\nprint(dd)\n\ndd.type\n\nDictDot(name='my object', description='please convert me', type='a good old fashioned dictionary')\n\n\n'a good old fashioned dictionary'\n\n\n\nsource\n\n\n\nsplit_str_to_obj\n\n split_str_to_obj (piped_str:str, key_ls:list[str])\n\nsplit a pipe separated list into an object with keys defined by the list of keys ex. “test_instance|myemail|sample_password”, [“domo_instance”, “domo_username”, “domo_password”] = {“domo_instance” : “test_intance” , “domo_username” : “myemail”, “domo_password”:“sample_password”}\n\n\nsample implementation of split_str_to_obj\n\ndd = split_str_to_obj(piped_str=\"test_instance|myemail|sample_password\",\n                 key_ls=[\"domo_instance\", \"domo_username\", \"domo_password\"])\n\ndd.domo_instance\n\n'test_instance'"
  },
  {
    "objectID": "utils/convert.html",
    "href": "utils/convert.html",
    "title": "Conversion utility functions",
    "section": "",
    "text": "Date related Functions\n\nsource\n\nconvert_epoch_millisecond_to_datetime\n\n convert_epoch_millisecond_to_datetime (epoch:int)\n\nconvert Epoch time with miliseconds to Date time\n\nsource\n\n\nconvert_datetime_to_epoch_millisecond\n\n convert_datetime_to_epoch_millisecond (datetime:datetime.datetime)\n\nconvert DateTime to Epoch time with Miliseconds\n\nsample implementations of convert_datetime\n\nimport time\nimport datetime as dt \n\ncur_time = int(time.time()*1000)\n\ncur_datetime =  convert_epoch_millisecond_to_datetime(cur_time)\nprint(cur_datetime)\n\ntest_time = convert_datetime_to_epoch_millisecond(cur_datetime)\nprint(test_time)\n\nfctest.test_eq(test_time, cur_time)\n\n2023-03-17 01:43:53.746000\n1679017433746\n\n\n\n\n\n\nText related Functions\n\nsource\n\nconvert_snake_to_pascal\n\n convert_snake_to_pascal (clean_str)\n\nconverts ‘snake_case_str’ to ‘snakeCaseStr’\n\nsample implementation of convert_snake_case_to_pascal\n\nconvert_str = 'test_snake_case'\n\nconvert_snake_to_pascal(convert_str)\n\n'testSnakeCase'\n\n\n\n\n\n\nDataFrame Conversion\n\nsource\n\nconcat_list_dataframe\n\n concat_list_dataframe (df_ls:list[pandas.core.frame.DataFrame])\n\ntake a list of dataframes and collapse into one dataframe\n\nsource\n\n\nConcatDataframe_InvalidElement\n\n ConcatDataframe_InvalidElement (elem)\n\nCommon base class for all non-exit exceptions.\n\ndf = pd.DataFrame([{\"col_a\" : \"a\", \"col_b\": \"b\", \"col_c\": \"c\"}])\n\ndf_ls = [ df, df, df] \n\nconcat_list_dataframe(df_ls)\n\n\n\n\n\n  \n    \n      \n      col_a\n      col_b\n      col_c\n    \n  \n  \n    \n      0\n      a\n      b\n      c\n    \n    \n      1\n      a\n      b\n      c\n    \n    \n      2\n      a\n      b\n      c"
  },
  {
    "objectID": "utils/upload_data.html",
    "href": "utils/upload_data.html",
    "title": "Upload Data to Domo",
    "section": "",
    "text": "source\n\nupload_data\n\n upload_data (data_fn, instance_auth:domolibrary.client.DomoAuth.DomoAuth,\n              consol_ds:domolibrary.classes.DomoDataset.DomoDataset,\n              partition_key:str=None, upload_method:str='REPLACE',\n              is_index:bool=False, debug_prn:bool=False,\n              debug_fn:bool=True, debug_api:bool=False,\n              logger:domolibrary.client.Logger.Logger=None,\n              max_retry:int=2)\n\n\nsample implementation of upload_data with loop\n\nimport os\nimport domolibrary.classes.DomoBootstrap as dmbsr\nimport httpx\nimport pandas as pd\n\n\nasync def data_fn(\n    instance_auth: dmda.DomoFullAuth,  # this API requires full auth\n    session: httpx.AsyncClient = None,\n    debug_api: bool = False,\n) -> pd.DataFrame:\n\n    \"\"\"function to call.  must return a dataframe.\"\"\"\n    try:\n        bsr = dmbsr.DomoBootstrap(auth=instance_auth)\n        instance_features = await bsr.get_features(debug_api=debug_api, session=session)\n\n        upload_df = pd.DataFrame(instance_features)\n        upload_df[\"instance\"] = instance_auth.domo_instance\n\n        return upload_df\n\n    except Exception as e:\n        print(f\"getting data : unexpected error: {e}\")\n        return None\n\n\n### get_auth\nfull_auth = dmda.DomoFullAuth(\n    domo_instance=\"domo-dojo\",\n    domo_username=\"jae@onyxreporting.com\",\n    domo_password=os.environ[\"DOJO_PASSWORD\"],\n)\n\n# confirm retrieves token\nassert isinstance(await full_auth.get_auth_token(), str)\n\nds_id = \"44c5af30-ea04-49e4-9d7a-529afd223590\"\nds = await dmds.DomoDataset.get_from_id(dataset_id=ds_id, auth=full_auth)\n\nawait upload_data(\n    instance_auth=full_auth,  # instance where the data_fn function will execute against\n    consol_ds=ds,\n    partition_key=full_auth.domo_instance,\n    data_fn=data_fn,\n    is_index=True,\n    debug_fn=True,\n    debug_api = False,\n    max_retry=2,\n)\n\n🏁 starting domo-dojo - data_fn\nstarting upload of 360 rows to domo-dojo in domo-dojo with 2 attempts\nattempt 1 for domo-dojo in domo-dojo\nattempt 2 for domo-dojo in domo-dojo\nattempt 3 for domo-dojo in domo-dojo\n🚀 success upload of domo-dojo to 44c5af30-ea04-49e4-9d7a-529afd223590 in domo-dojo in data_fn\n🥫 successfully indexed demo_instance_features in domo-dojo\n\n\nResponseGetData(status=200, response={'dataSourceId': '44c5af30-ea04-49e4-9d7a-529afd223590', 'uploadId': 467, 'dataTag': 'domo-dojo', 'status': 'SUCCESS', 'size': {'rowCount': 360, 'columnCount': 7, 'numberOfBytes': 20529, 'partCount': 1}, 'indexing': {'requested': False}}, is_success=True)\n\n\n\n# # | export\n# async def upload_data_with_date(\n#     instance_auth,\n#     data_fn,\n#     consol_ds,\n#     partition_date_col,\n#     partition_delimiter,\n#     start_date,\n#     end_date,\n#     debug_api: bool = False,\n#     debug_prn: bool = False,\n# ):\n\n#     instance_session = httpx.AsyncClient()\n\n#     print(\n#         f\"'🎬 upload_with_data: starting retrieval {start_date}, {end_date}, {instance_auth.domo_instance}\"\n#     )\n\n#     upload_df = await data_fn(\n#         instance_auth=instance_auth,\n#         session=instance_session,\n#         start_date=start_date,\n#         end_date=end_date,\n#         debug=debug,\n#     )\n\n#     await instance_session.aclose()\n\n#     if not isinstance(upload_df, pd.DataFrame):\n#         print(f\"🛑 error no data returned {instance_auth.domo_instance}\")\n#         print(upload_df)\n#         return None\n\n#     if debug_prn:\n#         print(\n#             f\"🧻 upload_with_data: starting upload {len(upload_df)} rows for {instance_auth.domo_instance}\"\n#         )\n\n#     task = []\n\n#     for index, partition_set in upload_df.drop_duplicates(\n#         subset=[partition_date_col]\n#     ).iterrows():\n#         partition_date = partition_set[partition_date_col]\n\n#         partition_key = (\n#             f\"{instance_auth.domo_instance}{partition_delimiter}{str(partition_date)}\"\n#         )\n\n#         task.append(\n#             consol_ds.upload_data(\n#                 upload_df=upload_df[(upload_df[partition_date_col] == partition_date)],\n#                 upload_method=\"REPLACE\",\n#                 partition_key=partition_key,\n#                 is_index=False,\n#                 debug_api=debug_api,\n#                 debug_prn=debug_prn,\n#             )\n#         )\n\n#     res = await asyncio.gather(*task)\n\n#     if debug_prn:\n#         print(\n#             f\"🎉 upload_with_data : finished uploading {len(upload_df)} rows for {instance_auth.domo_instance}\"\n#         )\n#     return res"
  },
  {
    "objectID": "utils/chunk_execution.html",
    "href": "utils/chunk_execution.html",
    "title": "Async Code Execution",
    "section": "",
    "text": "source\n\nrun_sequence\n\n run_sequence (*functions:Awaitable[Any])\n\nexecutes a sequence of functions\n\nSample Implementation of run_sequence\n\nimport asyncio\n\nasync def t1():\n    print('running t1')\n    await asyncio.sleep(1)\n    print(\"done running t1\")\n\nasync def t2():\n    print('running t2 next')\n    await asyncio.sleep(3)\n    print(\"done running t2\")\n\nasync def t3():\n    print('running t3 next')\n    await asyncio.sleep(2)\n    print(\"done running t3\")\n\n\nawait_ls = [t1(),t2(),t3()]\n\nawait run_sequence(*await_ls)\n\n# run_sequence uses the same syntax as asyncio.gather().  the following code sample is the same\n# await run_sequence( t1(),t2(),t3())\n\n# run_sequence forces sequential code execution as opposed to asyncio.gather\n# await asyncio.gather(*await_ls)\n\nrunning t1\ndone running t1\nrunning t2 next\ndone running t2\nrunning t3 next\ndone running t3\n\n\n\nsource\n\n\n\nchunk_list\n\n chunk_list (obj_ls:list[any], chunk_size:int)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nobj_ls\nlist\nlist of entities to split into n chunks\n\n\nchunk_size\nint\nentities per sub list\n\n\nReturns\nlist\nreturns a list of chunk_size lists of objects\n\n\n\n\nsample implementation of chunk_list\n\nnum_ls = list(range(50))\n\n# each list contains six elements\nchunk_list(num_ls, 6)\n\n[[0, 1, 2, 3, 4, 5],\n [6, 7, 8, 9, 10, 11],\n [12, 13, 14, 15, 16, 17],\n [18, 19, 20, 21, 22, 23],\n [24, 25, 26, 27, 28, 29],\n [30, 31, 32, 33, 34, 35],\n [36, 37, 38, 39, 40, 41],\n [42, 43, 44, 45, 46, 47],\n [48, 49]]\n\n\n\n# #| export\n# async def chunk_fn(chunk, api_fun, idx, sleep_time, session, list_id):\n#     print(f'sleeping {idx} and {len(chunk)}')\n\n#     res = await asyncio.gather(*[api_fun(row=row, session=session, list_id=list_id) for row in chunk])\n\n#     await asyncio.sleep(sleep_time)\n#     print(f'end_sleep {idx}')\n#     return res\n\n\n# #| export\n# async def api_request_in_chunks(full_list, api_fn, api_limit_size, list_id, sleep_time=10):\n#     chunked_list = chunk_list(tlist=full_list, chunk_size=api_limit_size)\n#     session = httpx.AsyncClient(request_class=OAuthRequest)\n#     res = await run_sequence(\n#         *[chunk_fn(chunk, api_fn, idx, sleep_time=sleep_time, session=session, list_id=list_id) for idx, chunk in\n#           enumerate(chunked_list)])\n#     await session.aclose()\n#     return res"
  },
  {
    "objectID": "integrations/domojupyter.html",
    "href": "integrations/domojupyter.html",
    "title": "DomoJupyter (GetInstanceCredentials)",
    "section": "",
    "text": "get_jupyter_account\nbasic function that uses the wraps the domojupyter get_account_property functions in a loop.\n\nsource\n\nget_jupyter_account\n\n get_jupyter_account (account_name:str, domojupyter_fn:<built-\n                      infunctioncallable>, maximum_retry:int=10)\n\nimport a domojupyter account, will loop until success\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\naccount_name\nstr\n\nname of account as it appears in the\n\n\ndomojupyter_fn\ncallable\n\n\n\n\nmaximum_retry\nint\n10\n\n\n\nReturns\n(<class ‘list’>, <class ‘dict’>)\n\n\n\n\n\n\nsource\n\n\nGetJupyter_ErrorRetrievingAccountProperty\n\n GetJupyter_ErrorRetrievingAccountProperty (account_name, property_name)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nGetJupyter_ErrorRetrievingAccount\n\n GetJupyter_ErrorRetrievingAccount (account_name)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nGetInstanceConfig\n\n GetInstanceConfig\n                    (logger:Optional[domolibrary.client.Logger.Logger]=Non\n                    e)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nNoConfigCompanyError\n\n NoConfigCompanyError (sql, domo_instance)\n\nCommon base class for all non-exit exceptions.\n\n\n\nGet Domo Jupyter Account objects\nA Class for converting DomoJupyter Account objects into DomoAuth account objects\n\nsource\n\nDomoJupyterAccount_InstanceAuth\n\n DomoJupyterAccount_InstanceAuth (account_name:str,\n                                  domo_username:str=None,\n                                  display_name:str=None,\n                                  domo_instance:str=None,\n                                  domo_instance_ls:list=None,\n                                  raw_cred:dict=None,\n                                  domo_password:str=None,\n                                  domo_access_token:str=None,\n                                  auth_ls:list=None)\n\nclass for interacting with DomoJupyterAccount objects and generating a DomoAuth object\n\nsource\n\n\nInvalidAccountTypeError\n\n InvalidAccountTypeError (account_name, account_type)\n\nraised when account type is not expected type\n\n\n\nGet Domains with Instance Config\nUse this method to configure a dataset that retrieves a list of domains from a config instance (using config credentials). Pass an auth_enum object to enumerate different authenticaiton variations to expect in the result dataset (see example).\nTheoretically, each of the enumerated auth variations should already exist in the instance.\nThe Config Dataset must return columns domo_instance and auth_match_col\n\nsource\n\nGetInstanceConfig.get_domains_with_instance_auth\n\n GetInstanceConfig.get_domains_with_instance_auth (config_dataset_id:str,\n                                                   config_auth:domolibrary\n                                                   .client.DomoAuth.DomoAu\n                                                   th, default_auth:domoli\n                                                   brary.client.DomoAuth.D\n                                                   omoAuth,\n                                                   auth_enum:enum.Enum,\n                                                   config_sql:str=\"select\n                                                   domain as domo_instance\n                                                   ,concat(config_useprod,\n                                                   '-', project) as\n                                                   auth_match_col from\n                                                   table\",\n                                                   debug_api:bool=False,\n                                                   debug_log:bool=False,\n                                                   debug_prn:bool=False, l\n                                                   ogger:domolibrary.clien\n                                                   t.Logger.Logger=None)\n\nuses a sql query to retrieve a list of domo_instances and map authentication object to each instance\n\nsource\n\n\nGetDomains_Query_AuthMatch_Error\n\n GetDomains_Query_AuthMatch_Error (sql:str=None, domo_instance:str=None,\n                                   message:str=None)\n\nraise if SQL query fails to return column named ‘auth_match_col’\n\nsample implementation of get_domains_with_instance_auth\n\nimport os\n\nconfig_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-DomoJupyter\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n)\n\ndefault_auth = dmda.DomoTokenAuth(\n    domo_instance=\"default\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\n\nclass AuthEnum(Enum):\n    \"\"\"enum_name must match values in auth_match_col from config_sql query\"\"\"\n\n    test_1 = dmda.DomoTokenAuth(\n        domo_instance=\"test_1\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n    )\n    test_0 = dmda.DomoTokenAuth(\n        domo_instance=\"test_0\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n    )\n\n\nlogger = lc.Logger(app_name=\"test_retrieve_company\")\n\nres = await GetInstanceConfig.get_domains_with_instance_auth(\n    config_auth=config_auth,\n    config_dataset_id=\"8d2a8055-7918-4039-b67d-361647e96ea8\",\n    config_sql=\"SELECT domain as domo_instance, 'test_1' as auth_match_col from Table\",\n    debug_prn=True,\n    debug_log=False,\n    debug_api=False,\n    logger=logger,\n    default_auth=default_auth,\n    auth_enum=AuthEnum,\n)\n\npd.DataFrame(res)\n# pd.DataFrame(logger.logs)\n\n⚙️ START - Retrieving company list \nhttps://domo-DomoJupyter.domo.com/datasources/8d2a8055-7918-4039-b67d-361647e96ea8/details/overview using \nSELECT domain as domo_instance, 'test_1' as auth_match_col from Table\n\n⚙️ SUCCESS 🎉 Retrieved company list \nThere are 1 companies to update\n\n\n\n\n\n\n  \n    \n      \n      domo_instance\n      auth_match_col\n      is_valid\n      instance_auth\n    \n  \n  \n    \n      0\n      domo-dojo\n      test_1\n      1.0\n      DomoTokenAuth(domo_instance='domo-dojo', token...\n    \n  \n\n\n\n\n\nsource\n\n\n\nDomoJupyterAccount_InstanceAuth.get_domo_instance_auth_account\n\n DomoJupyterAccount_InstanceAuth.get_domo_instance_auth_account\n                                                                 (account_\n                                                                 name:str,\n                                                                 domojupyt\n                                                                 er_fn:<bu\n                                                                 ilt-infun\n                                                                 ctioncall\n                                                                 able>, do\n                                                                 mo_instan\n                                                                 ce=None)\n\nretrieves Abstract Credential Store from DomoJupyter environment. expects credentials property to contain DOMO_USERNAME, DOMO_PASSWORD, or DOMO_ACCESS_TOKEN, and (optional) DOMO_INSTANCE\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\naccount_name\nstr\n\ndomojupyter account to retrieve\n\n\ndomojupyter_fn\ncallable\n\nDomo’s domojupyter module, pass in b/c can only be retrieved inside Domo jupyter notebook environment\n\n\ndomo_instance\nNoneType\nNone\nset the domo_instance or retrieve from the domojupyter_account credential store\n\n\n\n\nsource\n\n\nInvalidAccountNameError\n\n InvalidAccountNameError (account_name=None, regex_pattern=None)\n\nraised when account name does not follow format string\n\n# show_doc(DomoJupyterAccount_InstanceAuth.get_domo_account)\n\n\nsource\n\n\nDomoJupyterAccount_InstanceAuth.generate_auth_ls\n\n DomoJupyterAccount_InstanceAuth.generate_auth_ls\n                                                   (domo_instance_ls:list[\n                                                   str]=None)\n\nfor every domo_instance in domo_instance_ls generates an DomoAuth object\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndomo_instance_ls\nlist\nNone\nlist of domo_instances\n\n\nReturns\nlist\n\nlist of domo auth objects\n\n\n\n\nsource\n\n\nGenerateAuth_CredentialsNotProvided\n\n GenerateAuth_CredentialsNotProvided ()\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nGenerateAuth_InvalidDomoInstanceList\n\n GenerateAuth_InvalidDomoInstanceList ()\n\nCommon base class for all non-exit exceptions.\n\n# show_doc(DomoJupyterAccount_InstanceAuth.generate_auth_ls)\n\n\nDomoJupyterAccount_InstanceAuth(account_name=\"test\")\n\nDomoJupyterAccount_InstanceAuth(account_name='test', domo_username=None)\n\n\n\n\n\nGet Domains with Global Config (DEPRECATED)\nUse this method to configure a dataset that retrieves a list of domains from a config instance (using config credentials) and then includes a global_auth or global_exception_auth for each retrieved domo_instance which will be used to configure the instance.\nTheoretically, the global user should be an Admin alreado Domo’ed to the instance\nThe Config Dataset must return columns domo_instance and config_exception_pw\nNOTE: this method works as designed, but get_domains_with_instance_auth method is more flexible as it supports more variations by using an Enum class for matching.\n\nsource\n\nGetInstanceConfig.get_domains_with_global_config_auth\n\n GetInstanceConfig.get_domains_with_global_config_auth\n                                                        (config_dataset_id\n                                                        :str, config_auth:\n                                                        domolibrary.client\n                                                        .DomoAuth.DomoAuth\n                                                        , global_auth:domo\n                                                        library.client.Dom\n                                                        oAuth.DomoAuth, gl\n                                                        obal_exception_aut\n                                                        h:domolibrary.clie\n                                                        nt.DomoAuth.DomoAu\n                                                        th, config_sql:str\n                                                        ='select domain as\n                                                        domo_instance, con\n                                                        fig_exception_pw\n                                                        from table', debug\n                                                        _api:bool=False, d\n                                                        ebug_log:bool=Fals\n                                                        e, debug_prn:bool=\n                                                        False, logger:domo\n                                                        library.client.Log\n                                                        ger.Logger=None)\n\n\nsource\n\n\nGetDomains_Query_Exception_PW_Col_Error\n\n GetDomains_Query_Exception_PW_Col_Error (sql:str=None,\n                                          domo_instance:str=None,\n                                          message:str=None)\n\nraise if SQL query fails to return column named ‘config_exception_pw’\n\nsample implementation of get_domains_with_global_config_auth\n\nimport os\n\nconfig_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-DomoJupyter\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n)\n\nglobal_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-global\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nglobal_exception_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-global\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\n\nlogger = lc.Logger(app_name=\"test_retrieve_company\")\n\nres = await GetInstanceConfig.get_domains_with_global_config_auth(\n    config_auth=config_auth,\n    config_dataset_id=\"8d2a8055-7918-4039-b67d-361647e96ea8\",\n    config_sql=\"SELECT domain as domo_instance, 1 as config_exception_pw  from Table\",\n    debug_prn=True,\n    debug_log=False,\n    debug_api=False,\n    logger=logger,\n    global_auth=global_auth,\n    global_exception_auth=global_exception_auth,\n)\n\npd.DataFrame(res)\n# pd.DataFrame(logger.logs)\n\n⚙️ START - Retrieving company list \nhttps://domo-DomoJupyter.domo.com/datasources/8d2a8055-7918-4039-b67d-361647e96ea8/details/overview using \nSELECT domain as domo_instance, 1 as config_exception_pw  from Table\n\n⚙️ SUCCESS 🎉 Retrieved company list \nThere are 1 companies to update\n\n\n\n\n\n\n  \n    \n      \n      domo_instance\n      config_exception_pw\n      is_valid\n      instance_auth\n    \n  \n  \n    \n      0\n      domo-dojo\n      1\n      1.0\n      DomoTokenAuth(domo_instance='domo-dojo', token..."
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html",
    "title": "Domo Onboarding",
    "section": "",
    "text": "This document describes the best practices for beginner Domo users. There are different personas use cases covered in this document:\n🖊️ this is a working document (ish).  Leave comments if specific content doesn’t make sense or you need more information."
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#motivation",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#motivation",
    "title": "Domo Onboarding",
    "section": "Motivation",
    "text": "Motivation\nThis document contains a set of recommendations which will help end users:\n\nOptimize the development process\nReduce development efforts\nBe integrated into SIE process\nUnderstand how to improve the content searchability and accessibility\nUnderstand Domo tooling that can lead to improved customer satisfaction and engagement."
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#relevant-links",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#relevant-links",
    "title": "Domo Onboarding",
    "section": "Relevant Links",
    "text": "Relevant Links\nNew Features\nCurrent Release Notes\n🧵 Domo Training Slack Channel"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#core-domo-terms",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#core-domo-terms",
    "title": "Domo Onboarding",
    "section": "Core Domo Terms",
    "text": "Core Domo Terms\n\nDataSet: In Domo, a DataSet is a single flat table of data consisting of columns and rows.\nDatasets are stored as flat files in “Vault” (Amazon S3) before getting loaded into “Adrenaline” (parallel distributed database layer)\nDataFlow: a job in the Domo Data Center that makes transformations (e.g. joins, edits, calculations, etc.) to existing DataSets inside of Domo.\nThe output of a DataFlow is a new dataset (flat file) stored in Vault.\nAnalyzer: we design a Card in the Analyzer. The Analyzer is where we create and edit the card.\n﻿\nCard: synonymous with “chart”, “graph”, or “plot”\nUnderstanding Cards KB link\nEach card gets reduced to a SQL Query against the underlying dataset\n﻿\nDashboard/Page: a group of cards ﻿\nManaging Cards and Dashboards KB Link"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#unofficial-terms-scotts-terms",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#unofficial-terms-scotts-terms",
    "title": "Domo Onboarding",
    "section": "Unofficial Terms / “Scott’s Terms”",
    "text": "Unofficial Terms / “Scott’s Terms”\n\nWall: a term to represent Pages in Domo (e.g. “I can see a bunch of different walls in Domo”)\nPretty Picture: a term to represent Cards in Domo (e.g. I can see a bunch of pretty pictures hanging on a wall in Domo”)\nShell: A Card is like a Shell - we design the Shell in the Analyzer and the data from the chosen DataSet flows in the Shell and is displayed according to the Shell parameters (i.e. filters, time frame, etc.)"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#business-terms",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#business-terms",
    "title": "Domo Onboarding",
    "section": "“Business” Terms",
    "text": "“Business” Terms\n\nCharts, graphs: Any sort of graphic to visualize data\nDashboards: A collection of key business indicators organized and arranged on a single page"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#jae-recommendations",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#jae-recommendations",
    "title": "Domo Onboarding",
    "section": "Jae Recommendations",
    "text": "Jae Recommendations\n\nRecommended naming conventions for datasets/dataflows\nUse snake_case as it is easier to read.\nEx. MYPROJ_01_historisation_v1_PROD\n_<STAGE_ 1/2/X>__<Version 1/2/X>_\nNaming conventions allow the DSO team to track your utilization as well as facilitate data categorization.\n\nThe status of this dataset/dataflow. Also if you would like to create a copy and work on parallel development you just need to change the prefix to DEV and work on it.\nProject Code should be unique and will help us to monitor the rows allocation per project per instance\nStage allows you better to define the data lineage and identify dependencies\nDescription provides more information about the nature of transformation or business logic\nVersioning allows you to better manage the versioning (you might have PROD____ V1 and then you create DEV____ V2 to work on in the new version). This approach allows you to better control and separate different versions of dataflow.\n\n\n\nAccount Creation and Dataset Continuity\n\nManaging Accounts / Dataset Credentials when individuals go on PTO or leave the Company\nDomo KB Link\n“I’d like to know what is the current way we use the service account to manage connectors / credentials in Domo so that the management of those connectors can be spread across a few individuals.  Currently, our team members are creating those connectors in their own account causing maintenance issues when those individual is on PTO or left the company.”\nDatasets will continue executing using the stored credentials in an account object as long as the credentials are valid.  If a user is removed from Domo, the account is not automatically assigned, admins will need the Manage All Accounts role Grant to administer accounts that have not explicitly been shared with them.\nAssign Account ownership to a service account OR a Domo Group (beta)\nTake note that there are different account sharing levels, Read, Edit, Owner etc.\n\n\nCreating Accounts\nAccounts are created when users enter credentials for a datasource (Adobe Analytics, Salesforce, Snowflake etc). These credentials cannot be seen in plain text anywhere in Domo but are exchanged when a connector requests access from the source system.\nAccounts are owned by a user(s) or group.\n\nOwners can rename accounts and update the stored credentials (cycling credentials).  \nUsers who have Read access to an account can impersonate the stored credentials and create new data extracts from the source system.\n\n\n\n\nRecommended naming conventions for dataset columns\nWe recommend using snake case (article) for column names.\n\n\nRecommended tagging structure\nTo facilitate dataset classification, Jae requires the use of tags.  \nTags can be applied to datasets AND dataflows but they do not transfer automatically from a parent object to a child object.\n\nPrefix Breakdown\ncl_\nContent lifecycle\ncl_PROD\ncl_DEV\ncl_UAT\ncl_ARCHIVE\ncl_DELETE\npj_\nProject\npj_MONIT\n\n\nKnown Project Prefixes\npj_MONIT\nFor instance monitoring datasets (Domo_Governance, Domo_Stats etc).\n\n\n\nETL and Data Pipeline Development\nHow to Structure your DataCenter - video\n\nAlways comment you code (for MySQL/Redshift/Adrenaline flows) Each temporary table should be commented on purpose and what is the output\nTry to use clear names for Magic tiles (instead of generated one like Select Columns 1/2/3 or Remove duplicates)\nUse a bus matrix to organize and play your pipeline\nCategorize datasets as Fact or Dimension (and wait till the late steps to JOIN them\nAlways apply GROUP BY or DEDUPLICATION before JOIN’ing in ETL\nTry to UNION facts.  Do Not JOIN facts together.\nUse the ALTER COLUMNS tile to standardize data types\nUNION columns with an Activity_Type and Activity_Date for standard Filtering\nUsing WebForms you can join in descriptive information to augment datasets\nDon’t filter your output datasets in ETL. Filter in Cards or a DSV used as a Semantic Layer.\nRationalize when it’s appropriate to write business logic into Magic (Formula tiles), webform_lookups, vs. Beast Modes.\nDo not leverage DSVs for data transformation if you’re also using Magic. Try to keep all your transformation logic in the same place.\nIf you are writing the same code multiple times, find a different implementation strategy\nduring this stage of adoption (and given the small data) JUST do Magic & Beast Modes. Don’t use DSVs until Users demand an intermediate semantic layer.\n\n\n\nUse Change Log and Versioning\nDomo allows you to keep track of changes in the dataflow (all types).\n\n\nArchiving and Deleting Content\n🚀 Deleting a dataflow does not automatically delete connected datasets.\nTo properly decommission dataflows:\n\nRelabel the output datasets, DELETE_<dataset_name>\nRelabel the dataflow, DELETE_<dataflow_name>\nDelete dataflows and datasets\n\nThere is no archive feature built into Domo.  As a surrogate for archiving, users can\n\nDisable execution of dataflows, workbench jobs, or connector datasources\nUse Lineage to confirm datasets are not part of an operational pipeline\nRelabel and retag assets.\nCards and Pages can be moved from production pages and relabeled as appropriate."
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#supporting-features-from-domo",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#supporting-features-from-domo",
    "title": "Domo Onboarding",
    "section": "Supporting Features from Domo",
    "text": "Supporting Features from Domo\n\nAdrenaline Dataflows\nMagic 2.0\nCLI\nDataset Views\nPublish\nCertification\nAdvanced tools (Stacker, Data Assembler)"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#which-tool-is-the-best-for-which-use-case",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#which-tool-is-the-best-for-which-use-case",
    "title": "Domo Onboarding",
    "section": "Which tool is the best for which use case",
    "text": "Which tool is the best for which use case"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#upsert-and-partitioning-tools",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#upsert-and-partitioning-tools",
    "title": "Domo Onboarding",
    "section": "Upsert and Partitioning tools",
    "text": "Upsert and Partitioning tools"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#understanding-pages-and-dashboards",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#understanding-pages-and-dashboards",
    "title": "Domo Onboarding",
    "section": "Understanding Pages and Dashboards",
    "text": "Understanding Pages and Dashboards\nIn addition to default system dashboards (Overview, Favorites, Shared), as well as company-defined default dashboards, users can display content and cards on dashboards.\nPage owners and users with manage pages rights can lock a page to prevent alterations to a page.  Consider the use of Certification workflows for ‘official’ content that should not be altered."
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#change-card-interactions-to-control-what-happens-when-users-click-on-a-dashboard",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#change-card-interactions-to-control-what-happens-when-users-click-on-a-dashboard",
    "title": "Domo Onboarding",
    "section": "Change Card Interactions to control what happens when Users click on a Dashboard",
    "text": "Change Card Interactions to control what happens when Users click on a Dashboard\nDefault behavior is to apply filters on click, but dashboard designers change interaction behavior on a card by card basis.\nEx. Can have drilldown in place, or click to open a link to another Domo Page or external link.\nInteractions KB Link\nURL Links to pages can include predefined column filters using PFilters.  KB Link\n\nAdditional Resources\n\nDesign better Dashboards / Tell Better Data Stories (📹 YouTube Video)\nUnderstanding Pages (System Defaults - Overview, Favorites, Shared – KB Link)"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#understanding-cards",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#understanding-cards",
    "title": "Domo Onboarding",
    "section": "Understanding Cards",
    "text": "Understanding Cards\nCards are the Domo equivalent of charts, plots, or graphs.\nFiltering, Sorting, cards in the Details view\n\nSharing Cards to Pages vs Save As (creating a copy)\nSharing and Removing Access to Cards and Pages Link to KB\n\n\nLock your Cards and Pages to prevent users from editing the content.\n\n\nChart Colors\nColor Rules (“conditional formatting”) Link to KB\nChanging Default Colors in different Chart Types Link to KB\n🚀 Only one Default Theme (color palette) can exist per instance in the form of the Brand Kit feature.   Link to KB\n❓ “In Tableau when you select a field to color, it automatically assigns each distinct value a color. This is useful for say Department separation. We can then manually change it if needed.  How do you do it in Domo?”\n\nEither set color rules (for metrics) OR if you have a chart type that allows you to add a Series (ex. Grouped bar chart) it will assign a color to each unique value\n\n\n\nAggregation across Categories / Window Functions / Cumulative Sum\nThere are 3 ways to compare aggregates outside of the window of data you’re currently in\nSegments\nKB Link\nWindow Functions & Fixed Functions\nUltimate 2020 Window Function Tutorial 📹 YouTube Video\n3 Month Average Lag 📹 YouTube Video\nCertain Card Types allow cross category aggregation\nPeriod over Period\nRunning Total\n\n\nBeast Modes are formulas defined in Analyzer / Cards\nBeast Mode calculations will frequently use MySQL (and sometimes Redshift) syntax.\n🚀 Beast Modes can be applied before aggregation (at the row level) or after aggregation\nIn most cases, any CASE statement should occur INSIDE a beast mode.\nCASE statements and date-specific transforms that exist independently of aggregate functions should often move upstream and persist in the dataset itself.\n\n\nUnderstanding Card Sharing and Data Security\nCard and Page sharing versus data security are two very different functions with different implications.  \n⚠️ If you share a card or dashboard, you are implicitly giving READ access to the underlying dataset(s) represented in the entity.\n⚠️ If there is content that needs to be filtered on a per-user basis consider using PDP (Personalized Data Permissions) to apply row-level security to limit the rows of data in a dataset a user has access to."
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#jae-recommendations-1",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#jae-recommendations-1",
    "title": "Domo Onboarding",
    "section": "Jae Recommendations",
    "text": "Jae Recommendations\n\nCard Design\n🚀 Naming Convention Tip:  Update the card title to indicate cards with a drill path.\n\nConsider an asterisk, *,  or ALT  + 16, ►, to indicate cards with a drill path.\n\n🚀 There is a toggle to prevent users from drilling down to raw data\n\n\nBeast Mode Management\n\nUse Beast Mode Manager and DomoGovernance_BeastModes dataset to monitor beast mode proliferation in your instance\nCard performance is directly correlated SQL commands issued in beast modes where possible to avoid COUNT(DISTINCT) and text-based operations (REGEX or LIKE).\nWhen reasonable, materialize row-based transforms (date conversions) onto the dataset.\nSharing beast modes to datasets will improve card performance but will slow dataset indexing.\nThere is a difference between sharing a card versus making a copy of a card.  Cards can be shared (linked) to multiple pages making it easy to have one object to maintain.\n\n\n\nCard and Dashboard Management\n\nEach card has its own URN.  You can either create a copy / duplicate of a card and embed it on a page (it will have its own URN) OR simply move or share a card to a page (it retains the original URN)."
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#card-faq",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#card-faq",
    "title": "Domo Onboarding",
    "section": "Card FAQ",
    "text": "Card FAQ\nIs there a difference between “Save As” / “Duplicating” vs “Sharing” a card?\n\nSave As or Duplicate will create a new object in Domo that is separate from the original entity.  \nChanges made to the duplicated card or the original card will not impact the other.  \nDuplicating Cards KB\n\nCan I prevent users from altering my card or page?\n\nYes, lock your content.  KB Link\nConsider a certification flow for ‘official content’.  KB Link\n\nHow can I alias data (fix values) or create a custom calculated metric in a card?\n\nCreate a Beast Mode Link KB using MySQL syntax functions\nEx. CASE WHEN END or SUM(CASE WHEN …  END)"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#card-features-for-participants-non-editors",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#card-features-for-participants-non-editors",
    "title": "Domo Onboarding",
    "section": "Card Features for Participants (non-editors)",
    "text": "Card Features for Participants (non-editors)\n\nUse Annotations to share insights\nCreate card annotations and find or document interesting insights using annotations\n\nAnnotation KB\n\n\n\nUse Alerts to update users with changes in Domo\n\nAlerts KB\n\nAlerts can be configured for cards and metrics represented in cards as well as datasets."
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#card-features-for-editors",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#card-features-for-editors",
    "title": "Domo Onboarding",
    "section": "Card Features for Editors",
    "text": "Card Features for Editors\n\nUse Quick Filters to encourage data exploration\n\nQuick Filters KB \n\n\n\nUse Page-level Filter Views to create preset combinations of filters for a guided user experience\n\nFilter Views KB\n\n\n\nAdd Drill Paths to Cards to control the exploration experience\n\nDrill Paths KB"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#documentation",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#documentation",
    "title": "Domo Onboarding",
    "section": "Documentation",
    "text": "Documentation\n\nHigh Level Design / Solution overview\nNew Users’ guide\nData Dictionary (see section below)"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#data-quality",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#data-quality",
    "title": "Domo Onboarding",
    "section": "Data Quality",
    "text": "Data Quality"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#domo-momentum---certification",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#domo-momentum---certification",
    "title": "Domo Onboarding",
    "section": "Domo Momentum - Certification",
    "text": "Domo Momentum - Certification"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#dev-prod-maintenance",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#dev-prod-maintenance",
    "title": "Domo Onboarding",
    "section": "Dev / Prod & Maintenance",
    "text": "Dev / Prod & Maintenance\n\nUse Domo Sandbox for managing same instance and cross-instance dev/prod content\n\nBy default SIE Domo instances will not have a second Domo instance to separate Dev from Prod.  Within the same instance however, Domo Sandbox can help manage the promotion of development assets to production and back. Sandbox KB \nDo not make full copies of production datasets into Dev; instead, consider developing against randomized samples of data.  This will both help manage developer experience (faster execution times) and instance rowcount.\n\n\n\nTransfer Assets to Appropriate Stakeholders"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#single-sign-on-sso-and-okta-authentication",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#single-sign-on-sso-and-okta-authentication",
    "title": "Domo Onboarding",
    "section": "Single Sign On (SSO) and OKTA Authentication",
    "text": "Single Sign On (SSO) and OKTA Authentication\nUser and Group Management KB link\nUsers can be aJaed to Domo at will.  The SIE Domo contract does not charge licensing fees on a per user basis.\nSee Adding Users to Domo KB link\nOut of the box, Domo user authentication is handled with email and login.  User provisioning and authentication can be handled via SSO (SSO using SAML KB link)\n\nLogging into Domo via Direct Sign On in an environment with SSO\nTo bypass SSO Authentication, users must first be added to the Direct Sign On (DSO) List.  \nOnce aJaed to DSO, users can bypass SSO by adding /auth/index?domoManualLogin=true to the url."
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#users-groups-roles",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#users-groups-roles",
    "title": "Domo Onboarding",
    "section": "Users, Groups, Roles",
    "text": "Users, Groups, Roles\n\n⚖️ SIE Standard Roles\nRoles are comprised of Grants which determine actions users can take in Domo.\nJae will create standard roles and groups to which instance members will be assigned by default.  Instance admins can create their own custom roles for departmental users as necessary.\n\nSIE_Admin\nSIE_Reset\nSIE_Priviliged\nPrivileged + ADR Flows\nSIE_Test\n\nTo monitor role & Grant configuration:\n\nGo To Admin > Governance > Roles > Grid\n\n\n\nDefine Custom Roles\n\nhttps://knowledge.domo.com/Administer/Controlling_Access_in_Domo/Managing_Custom_Roles\nhttps://knowledge.domo.com/Administer/Controlling_Access_in_Domo/04Security_Role_Reference\n\n\n\n⚖️ SIE Default Groups\n\nSIE Admin\nSIE User\n\n\n\nDefining Groups\nWhere Roles and Grants define what users can do, Group membership should be used to either:\n\nManage content ownership\nShare content\n\nAvoid the temptation to manage content by individuals, instead try to adopt the practice of sharing content with groups.\n\nhttps://domohelp.domo.com/hc/en-us/articles/360042934294-Creating-and-Managing-User-Groups\n\n\n\nImplement Row-Level Security with Personalized Data Permissions (PDP)  Policies\n🚀 Monitoring card sharing is NOT a replacement for applying PDP policies.  Jae strongly recommends applying PDP policies to all sensitive data in Domo.\n🚀 A card gets reduced to a SQL query against a dataset which is executed at runtime (i.e. when Michelle tries to view the card).  AND PDP creates row-level security to the dataset which limits what gets returned by the query.\nex. Michelle can create a card against any dataset that has been shared with her, but she will only see the rows the pdp policy allows her to see.\nex. SELECT Product, sum(amount) GROUP BY Product.\n🚀 PDP policies are additive (each policy you’re a part of adds an OR clause for the data you can see).\n\nPDP Links\n\nPersonalized Data Permissions - KB Link\nhttps://domohelp.domo.com/hc/en-us/articles/4415800746391-Governance-Toolkit-PDP-Automation\nhttps://domohelp.domo.com/hc/en-us/articles/360043439353-PDP-Policy-Autocreation"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#datacenter-audits",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#datacenter-audits",
    "title": "Domo Onboarding",
    "section": "Datacenter Audits",
    "text": "Datacenter Audits\n\nCreate a schedule with your technology & business users to clean up on a regular basis and monitor the results through governance and activity logs\nSet cleaning campaigns to a theme to make it fun\nCheck to make sure your instance objects are in security compliance with other parts of the business\nSet alerts on ETL jobs to monitor failure – can set up as SMS message\nCheck schedules for ETL jobs and make sure they are available when needed for the business dashboard users\n\n\nSecurity\n⚠️ By default, most users will not see all the data available in the datacenter; however, sharing a card automatically shares the underlying dataset.  Therefore PDP (personalized data permissions KB) is the only way to implement proper data security."
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#manage-data-using-metadata",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#manage-data-using-metadata",
    "title": "Domo Onboarding",
    "section": "Manage Data using Metadata",
    "text": "Manage Data using Metadata\n\nUse Tags facilitate dataset audits and provide additional dataset metadata (KB)\nUtilize the Governance Connectors (KB) to access data schemas, beastmodes, access rights to dataset, and tags\nCreate a data dictionary dashboard"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#monitor-domo-instance-and-projects",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#monitor-domo-instance-and-projects",
    "title": "Domo Onboarding",
    "section": "Monitor Domo Instance and Projects",
    "text": "Monitor Domo Instance and Projects"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#domo-architecture-review",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#domo-architecture-review",
    "title": "Domo Onboarding",
    "section": "Domo Architecture Review",
    "text": "Domo Architecture Review"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#data-science-toolkit",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#data-science-toolkit",
    "title": "Domo Onboarding",
    "section": "Data Science Toolkit",
    "text": "Data Science Toolkit\n\nJupyter Notebook\nKB link\nPrimary Advantages\n\nNotebooks can be scheduled to run as a dataflow\nDatasets can be read in or updated using the domo jupyter package\nDuring development, the performance of the notebooks will feel much faster than Magic 2.0 Scripting Tiles\n\nDisadvantages\n\nNo built-in version control (no access to private GitHub)\nNo easy way to “download all files”"
  },
  {
    "objectID": "blog/posts/2023-01-24_Domo_Onboarding/index.html#extending-domo-with-apis",
    "href": "blog/posts/2023-01-24_Domo_Onboarding/index.html#extending-domo-with-apis",
    "title": "Domo Onboarding",
    "section": "Extending Domo with APIs",
    "text": "Extending Domo with APIs\n📚 Jae Private API documentation"
  },
  {
    "objectID": "blog/posts/2023-01-24_DomoVariables/index.html",
    "href": "blog/posts/2023-01-24_DomoVariables/index.html",
    "title": "Domo Variables",
    "section": "",
    "text": "https://domo-dojo.domo.com/page/1880852133\n\nVariable Types\n\nText,number, date\nControls\n\nVariable Grant\n\nThree new Variable and Beast Mode, Domo STats Datasets\n\nFAQ\nDoes Variables support dynamic formatting – no\nUnknown if supports Optimization by Domo Engineering\nVariable is added as a dataset column\nVariables exist at a Global Scope across Domo and a Card Scope\nThe GRANT does not prevent users from altering variables\n\n\nQuestions from Oct CAB\nVariables for WHAT-IF Analysis\n\nPreviously would have to CROSS JOIN a webform to add a column to the dataset\nSave Variable / Dataset\nTO EXPLORE - column switching\nCASE WHEN VARIABLE = ‘value’ THEN  END\nVariables for switching EXCHANGE RATE\nCASE WHEN VARIABLE = ‘USD’ then  END\nVariables + Publish?\nVariables + Smart Text?\nGrants for separating Global vs. Personal variables?\nImpact when data changes with large datasets?\nWHY IS THERE NO KB?? - because it’s not in GA :)\nBECAUSE THEY DON’T CARE ABOUT DOCUMENTATION - true"
  },
  {
    "objectID": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html",
    "href": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html",
    "title": "Domo Distribution and Governance Strategy across Instances",
    "section": "",
    "text": "This is a framework for managing data distribution within an organization that has several departments using standalone instances of domo.\ndomo-accounting.domo.com\ndomo-sales.domo.com\ndomo-marketing.domo.com\ndomo-engineering.domo.com\nThere are several highly bespoke datastores that provide high value data to different departments, they’ll have their own instances of domo too.\ndomo-aa.domo.com\ndomo-sfdc.domo.com\ndomo-snowflake.domo.com\nWe need a single place where users can find trusted dashboards builton a consistent and validated data pipeline that will consume input datasets from different departments or a chain of transformed datasets.\nEx. The executive dashboard gets prepared by domo-engineering but consumes data from accounting, sales, and marketing."
  },
  {
    "objectID": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#types-of-datasets-and-which-ones-we-publish",
    "href": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#types-of-datasets-and-which-ones-we-publish",
    "title": "Domo Distribution and Governance Strategy across Instances",
    "section": "4 Types of Datasets and Which ones we Publish",
    "text": "4 Types of Datasets and Which ones we Publish"
  },
  {
    "objectID": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#non-publishable-datasets",
    "href": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#non-publishable-datasets",
    "title": "Domo Distribution and Governance Strategy across Instances",
    "section": "Non-publishable Datasets",
    "text": "Non-publishable Datasets\nAvoid publishing datasets that require additional lookups or external data to understand.\n\nRaw Datasets\n\n\nCome straight from the source system.\nMinimize ETL during Ingest.\n\n\nStaging Dataset (INT)\n\n\nExist exclusively in Department or Clearinghouse instances.\nRepresent intermediate steps required to transform a dataset into a usable shape.\nThis will include dimension tables that are not golden records"
  },
  {
    "objectID": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#publishable-datasets",
    "href": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#publishable-datasets",
    "title": "Domo Distribution and Governance Strategy across Instances",
    "section": "Publishable Datasets",
    "text": "Publishable Datasets\nWe promote the publishing of datasets that can stand on their own and do not require additional context to understand.\n\nData Warehouse (DWH)\n\n\nThe building blocks (inputs) to DASH datasets\n\nither facts or dimensional tables that have NOT been shaped for a specific analytic use case.\n\nDo not publish cards or dashboards built on DWH datasets.\nFact tables can take the form of transactional, accumulating snapshot, periodic balance.\nPeriod and accumulating snapshots should be avoided unless there’s a tradeoff for data volume optimization OR rigid reporting requirements where taking snapshots make sense (ex. Financial reporting)\nDWH datasets will be fact tables representing a single fact type (ex. Sales, Sales Forecast or Inventory), joined with the minimum dimensional attributes to be useful in a stand-alone setting.\nAvoid subsetting similar datasets (ex. Inventory 2019 vs Inventory 2022)\nDWH datasets includes conformed dimensional tables (like a Calendar Dimension with FY attributes or golden record customer master)\n\n\nDashboard Dataset (DASH)\n\n\nRepresent stand-alone datasets that dashboards and cards are built against.\nPublishable only to distribution centers.\nTypically will combine multiple DWH fact tables and conformed dimensions.\nDatasets shaped for analysis (PIVOT or UNPIVOT metrics, or POP (CY vs PY etc. are classified as DASH datasets).\nDo not conduct ETL on DASH datasets"
  },
  {
    "objectID": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#engineering-produces-a-dashboard",
    "href": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#engineering-produces-a-dashboard",
    "title": "Domo Distribution and Governance Strategy across Instances",
    "section": "1. Engineering produces a dashboard",
    "text": "1. Engineering produces a dashboard\nEngineering owns “database_monitoring” (dbm) and publishes a dashboard to the PDC (public distribution center)\n\nDATASOURCE via raw - dbm_RAW\nETL to produce dbm_DWH and dbm_DASH\nDISTRIBUTE via publish to PDC (dbm_DASH)"
  },
  {
    "objectID": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#infosec-augments-engineerings-dashboard",
    "href": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#infosec-augments-engineerings-dashboard",
    "title": "Domo Distribution and Governance Strategy across Instances",
    "section": "2. Infosec augments Engineering’s dashboard",
    "text": "2. Infosec augments Engineering’s dashboard\nInfosec wants to augment database_monitoring (dbm) published by Engineering and publish it as a new asset in PDC (public distribution center)\n\nDATASOURCES\nvia subscription from engineering (dbm_DWH)\nBecause we do not do publish DASH between departmental instances\nRAW data from internal sources\nETL produces infosec_DWH and infosec_DASH\nDISTRIBUTE via publish to PDC (infosec_DASH)"
  },
  {
    "objectID": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#secops-chooses-the-most-downstream-branch",
    "href": "blog/posts/2023-01-24-Domo_Everywhere_MultiInstance/index.html#secops-chooses-the-most-downstream-branch",
    "title": "Domo Distribution and Governance Strategy across Instances",
    "section": "3. SecOps chooses the most downstream branch",
    "text": "3. SecOps chooses the most downstream branch\nSecurity Operations wants to augment the work from Infosec and publish it as a new asset in PDC.\n\nThis introduces a 3-step ETL chain (RAW, engineering (dbm_DWH), or infosec (infosec_DWH) that SecOps must choose where to branch from.\n\nPublish / Subscriber requests should be configured from the most downstream certified data owner – in this case infosec.\n\nIf an update is made to how engineering handles database_monitoring, this ensures the update is passed to infosec. If infosec updates their ornamentation, that update passes down to SecOps and anyone who has branched off of it."
  },
  {
    "objectID": "blog/posts/2023-03-13-Custom_Roles/index.html",
    "href": "blog/posts/2023-03-13-Custom_Roles/index.html",
    "title": "Creating and UPSERTing custom roles with DomoLibrary",
    "section": "",
    "text": "a short post on using DomoLibrary to create and update custom roles with new grant lists and auto assign users to that role"
  },
  {
    "objectID": "blog/posts/2023-03-13-Custom_Roles/index.html#configure-environment-variables",
    "href": "blog/posts/2023-03-13-Custom_Roles/index.html#configure-environment-variables",
    "title": "Creating and UPSERTing custom roles with DomoLibrary",
    "section": "⚙️ configure environment variables",
    "text": "⚙️ configure environment variables\nThis script assumes the use of a dotenv file (in this example sample_config.txt)\n\n# pip install python-dotenv\n\n\nfrom dotenv import dotenv_values\n\nenv = dotenv_values(\"sample_config.txt\")\nenv\n\nOrderedDict([('ROLE_NAME', 'dl_department_admin'),\n             ('ROLE_DESCRIPTION', 'deployed via domo_library script'),\n             ('ROLE_GRANTS',\n              'alert.edit, alert.actions, content.card.embed, content.export, content.variable.edit, audit, datastore.create, dataset.manage, dataset.export, publish.subscribers.manage, user.invite, group.edit, certifiedcontent.admin, certifiedcontent.request'),\n             ('ROLE_EMAILS', 'test1@test.com, test2@test.com'),\n             ('ROLE_NAME2', 'dl_test'),\n             ('ROLE_DESCRIPTION2', 'deployed via domo_library script'),\n             ('ROLE_GRANTS2', 'alert.edit, alert.actions, content.card.embed'),\n             ('ROLE_EMAILS2',\n              'test3@test.com, test3@test.com, test4@test.com')])"
  },
  {
    "objectID": "blog/posts/2023-03-13-Custom_Roles/index.html#creds-config-and-roles-to-create",
    "href": "blog/posts/2023-03-13-Custom_Roles/index.html#creds-config-and-roles-to-create",
    "title": "Creating and UPSERTing custom roles with DomoLibrary",
    "section": "⚙️ Creds config and roles to create",
    "text": "⚙️ Creds config and roles to create\nthe domolibrary features a class based and function based approach to interacting with domo entities.\nuse the domolibrary.client.DomoAuth objects to handle api authentication\naccess_tokens can be configured in Domo > Auth > Security > Access Token and have the benefit of not requiring direct signon access in environments that are using SSO\n\n# pip install domolibrary --upgrade\n\n\nimport domolibrary.client.DomoAuth as dmda\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(domo_instance = 'domo-dojo', domo_access_token= os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\nawait token_auth.get_auth_token()\n\nassert isinstance(token_auth.token, str)"
  },
  {
    "objectID": "blog/posts/2023-03-13-Custom_Roles/index.html#templatize-user-input-with-classes",
    "href": "blog/posts/2023-03-13-Custom_Roles/index.html#templatize-user-input-with-classes",
    "title": "Creating and UPSERTing custom roles with DomoLibrary",
    "section": "Templatize user input with classes",
    "text": "Templatize user input with classes\nThe custom EnvRole class allows users to define configuration in the .env file; however ensures conformity and reduces code redundancy by templatizing the required input.\n\nfrom pprint import pprint\nfrom dataclasses import dataclass\nimport domolibrary.classes.DomoGrant as dmg\n\n@dataclass\nclass EnvRole:\n    name: str\n    description: str\n    grant_ls : [dmg.DomoGrant] # grants are consistent across domo instances so can be defined on initialization\n    user_ls : [str] # each instance would have a diferent user_id associated with each instance so should be handled on a per instance basis (DomoUsers expect a set user id)\n\n    \"\"\"custom class for templatizing roles to create\"\"\"\n\n    def __init__(self, name: str,\n                 description: str,\n                 grants_str: str,  # comma separated string of grant_ids\n                 user_str: [str]\n                 ):\n        self.name = name\n        self.description = description\n        self.grant_ls = [dmg.DomoGrant(id = grant.strip()) for grant in grants_str.split(',')]\n        self.user_ls = [user.strip() for user in user_str.split(',')]\n\n\n        # List of roles that will be created\nroles_to_create = [EnvRole(name=env['ROLE_NAME'],\n                           description=env['ROLE_DESCRIPTION'],\n                           grants_str=env['ROLE_GRANTS'],\n                           user_str = env['ROLE_EMAILS']\n                           ),\n\n                   EnvRole(name=env['ROLE_NAME2'],\n                           description=env['ROLE_DESCRIPTION2'],\n                           grants_str=env['ROLE_GRANTS2'],\n                           user_str = env['ROLE_EMAILS2']\n                           ),\n                ]\n\npprint(roles_to_create)\n\n[EnvRole(name='dl_department_admin',\n         description='deployed via domo_library script',\n         grant_ls=[DomoGrant(id='alert.edit',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='alert.actions',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='content.card.embed',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='content.export',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='content.variable.edit',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='audit',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='datastore.create',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='dataset.manage',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='dataset.export',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='publish.subscribers.manage',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='user.invite',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='group.edit',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='certifiedcontent.admin',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='certifiedcontent.request',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None)],\n         user_ls=['test1@test.com', 'test2@test.com']),\n EnvRole(name='dl_test',\n         description='deployed via domo_library script',\n         grant_ls=[DomoGrant(id='alert.edit',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='alert.actions',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None),\n                   DomoGrant(id='content.card.embed',\n                             display_group=None,\n                             title=None,\n                             depends_on_ls=None,\n                             description=None,\n                             role_membership_ls=None)],\n         user_ls=['test3@test.com', 'test3@test.com', 'test4@test.com'])]"
  },
  {
    "objectID": "blog/posts/2023-03-13-Custom_Roles/index.html#define-functions-that-bridge-the-envrole-with-domolibrary-classes",
    "href": "blog/posts/2023-03-13-Custom_Roles/index.html#define-functions-that-bridge-the-envrole-with-domolibrary-classes",
    "title": "Creating and UPSERTing custom roles with DomoLibrary",
    "section": "Define Functions that bridge the EnvRole with domolibrary classes",
    "text": "Define Functions that bridge the EnvRole with domolibrary classes\nIn the examples below, the functions are very simple and just call the API with passthrough parameters; however, more customization could be added for example defining a default role_description if one wasn’t provided.\nNotice how upsert_super_admin doesn’t even accept a list of grants and instead pulls a list of all available grants from that Domo Instance.\nThis might be necessary because Domo by default doesn’t grant all grants to the Admin role.\n\nimport domolibrary.classes.DomoRole as dmr\nimport domolibrary.client.DomoAuth as dmda\n\n\nasync def upsert_role(auth: dmda.DomoAuth,\n                      role_name: str,\n                      role_description: str,\n                      grant_ls: [dmg.DomoGrant],\n                      debug_api: bool = False, debug_prn: bool = False):\n\n    return await dmr.DomoRoles.upsert_role(auth=auth,\n                                           name=role_name,\n                                           description=role_description,\n                                           grant_ls=grant_ls)\n\n\nsample implementation of upsert_role\n\nimport datetime as dt\n\nrole = roles_to_create[0]\n\nawait upsert_role(auth=token_auth,\n                  role_name=role.name,\n                  role_description = f\"{role.description} - updated {dt.date.today()}\",\n                  grant_ls = role.grant_ls,\n                  debug_prn=True)\n\nDomoRole(id=1563101750, name='dl_department_admin', description='deployed via domo_library script - updated 2023-03-17', is_system_role=0, grant_ls=[DomoGrant(id='alert.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataset.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.card.embed', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='certifiedcontent.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='datastore.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='group.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='publish.subscribers.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='certifiedcontent.request', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='alert.actions', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.export', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='audit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataset.export', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='user.invite', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.variable.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None)], membership_ls=[])\n\n\n\nimport datetime as dt\nimport domolibrary.classes.DomoInstanceConfig as dmic\n\n# grants for super admin role are getting directly from instance using get_all_instance_grants\nasync def upsert_super_admin(auth: dmda.DomoAuth,\n                             role_name: str,\n                             role_description=f'all grants - updated on {dt.date.today()}',\n                             debug_api: bool = False,\n                             debug_prn: bool = False):\n\n    domo_instance = dmic.DomoInstanceConfig(auth = auth)\n    all_grants = await domo_instance.get_grants()\n\n\n    sa_role = await dmr.DomoRoles.upsert_role(name=role_name,\n                                              description=role_description,\n                                              auth=auth,\n                                              debug_api=debug_api,\n                                              grant_ls = all_grants\n                                              )\n\n    return sa_role\n\n\n\nsample implementation of creating a super_admin role\n\nawait upsert_super_admin(auth = token_auth, role_name = 'super_admin')\n\nDomoRole(id=810756122, name='super_admin', description='last updated - 2023-03-17', is_system_role=0, grant_ls=[DomoGrant(id='versions.deployment.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='buzz.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataflow.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='goal.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataset.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='workflow.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='account.view.all', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='profile.achieve.assign', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='datascience.notebooks.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.dataapp.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataset.export', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='user.invite', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='connector.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.card.analyzerview', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='fileshare.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='customer.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.variable.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='pipeline.executor.job.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='cloud.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='versions.repository.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='codeengine.package.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='appstore.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='datastore.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='certifiedcontent.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='group.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='tasks.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='group.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='app.ddx', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='queue.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='workbench.enterprise.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='domoapps.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.export', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='codeengine.package.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='domo.system.messages', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataset.account.create.big.query', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='publish.space.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='authorization.roles', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataset.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='goal.distribute', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='appstore.read', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.card.embed', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='user.session.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='workbench.enterprise.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='cloud.override', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='datastore.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='user.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='account.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.card.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='saasaas.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='developer.token.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='publish.subscribers.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='certifiedcontent.request', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.page.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='alert.actions', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='ml.execute', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='audit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='domoapps.read', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='tasks.private.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='content.card.narrative.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='approvalcenter.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='workbench.enterprise.view', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='datascience.notebooks.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataset.account.create.federated.oauth', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='form.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='pipeline.executor.job.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='alert.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='fileshare.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='appstore.payments.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='publish.publication.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataflow.adrenaline', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='workbench.download', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataset.account.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='usage.reports.view', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='goal.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='versions.repository.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='app.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataflow.magic', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='dataflow.manage', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='workflow.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='form.create', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='queue.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='alert.admin', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None), DomoGrant(id='appstore.edit', display_group=None, title=None, depends_on_ls=None, description=None, role_membership_ls=None)], membership_ls=[])"
  },
  {
    "objectID": "blog/posts/2023-03-13-Custom_Roles/index.html#create-user",
    "href": "blog/posts/2023-03-13-Custom_Roles/index.html#create-user",
    "title": "Creating and UPSERTing custom roles with DomoLibrary",
    "section": "create user",
    "text": "create user\nAt code execution, it is possible that a user may need to be a specific role, but that user and the role haven’t been deployed to the instance yet.\nThe proper order of operations would be to create a role and then assign the user to that role. You cannot create a user without defining their role membership\n\nimport domolibrary.classes.DomoUser as dmu\n\n\nasync def upsert_user(auth: dmda.DomoAuth,\n                      email_address: str,\n                      role_id: str,\n                      debug_api: bool = False,\n                      ):\n\n    return await dmu.DomoUsers.upsert_user(email_address=email_address,\n                                        role_id=role_id,\n                                        auth=auth,\n                                        debug_api=debug_api)\n\n\nsample implementation of upsert_user\n\nrole = roles_to_create[0]\nawait upsert_user( auth = token_auth, role_id = 4, email_address = 'test23@test.com')\n\nResponseGetData(status=200, response={'attributes': [{'key': 'id', 'values': [1802840904]}, {'key': 'displayName', 'values': ['test23@test.com - via dl 2023-03-16']}, {'key': 'userName', 'values': ['test23@test.com']}, {'key': 'emailAddress', 'values': ['test23@test.com']}, {'key': 'modified', 'values': [1679013796403]}, {'key': 'created', 'values': [1679010842000]}, {'key': 'roleId', 'values': [4]}, {'key': 'isAnonymous', 'values': [True]}, {'key': 'isSystemUser', 'values': [False]}, {'key': 'isPending', 'values': [True]}, {'key': 'isActive', 'values': [True]}, {'key': 'invitorUserId', 'values': [1893952720]}, {'key': 'avatarKey', 'values': ['/api/content/v1/avatar/USER/1802840904']}], 'id': 1802840904, 'displayName': 'test23@test.com - via dl 2023-03-16', 'roleId': 4, 'userName': 'test23@test.com', 'emailAddress': 'test23@test.com'}, is_success=True)"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "nbdev Blog",
    "section": "",
    "text": "Creating and UPSERTing custom roles with DomoLibrary\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nDomo Onboarding\n\n\n\n\n\n\n\nnew user\n\n\n\n\n\n\n\n\n\n\n\nJan 24, 2023\n\n\nJae Wilson\n\n\n\n\n\n\n  \n\n\n\n\nDomo Variables\n\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\n\n\n\n\n\nJan 24, 2023\n\n\nJae Wilson\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDomo Distribution and Governance Strategy across Instances\n\n\n\n\n\n\n\nDomo Everywhere\n\n\n\n\n\n\n\n\n\n\n\nJan 24, 2023\n\n\nJae Wilson\n\n\n\n\n\n\nNo matching items"
  }
]